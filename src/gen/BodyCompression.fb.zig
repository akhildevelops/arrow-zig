//!
//! generated by flatc-zig
//! binary:     src/gen/format/Message.bfbs
//! schema:     format/Message.fbs
//! file ident: //Message.fbs
//! typename    BodyCompression
//!

const std = @import("std");
const fb = @import("flatbufferz");
const Builder = fb.Builder;

const BodyCompressionMethod = @import("BodyCompressionMethod.fb.zig").BodyCompressionMethod;
const CompressionType = @import("CompressionType.fb.zig").CompressionType;

/// Optional compression for the memory buffers constituting IPC message
/// bodies. Intended for use with RecordBatch but could be used for other
/// message types
pub const BodyCompressionT = struct {
    /// Compressor library.
    /// For LZ4_FRAME, each compressed buffer must consist of a single frame.
    codec: CompressionType = @intToEnum(CompressionType, 0),
    /// Indicates the way the record batch body was compressed
    method: BodyCompressionMethod = @intToEnum(BodyCompressionMethod, 0),

    pub fn Pack(rcv: BodyCompressionT, __builder: *Builder, __pack_opts: fb.common.PackOptions) fb.common.PackError!u32 {
        _ = .{__pack_opts};
        var __tmp_offsets = std.ArrayListUnmanaged(u32){};
        defer if (__pack_opts.allocator) |alloc| __tmp_offsets.deinit(alloc);
        try BodyCompression.Start(__builder);
        try BodyCompression.AddCodec(__builder, rcv.codec);
        try BodyCompression.AddMethod(__builder, rcv.method);
        return BodyCompression.End(__builder);
    }

    pub fn UnpackTo(rcv: BodyCompression, t: *BodyCompressionT, __pack_opts: fb.common.PackOptions) !void {
        _ = .{__pack_opts};
        t.codec = rcv.Codec();

        t.method = rcv.Method();
    }

    pub fn Unpack(rcv: BodyCompression, __pack_opts: fb.common.PackOptions) fb.common.PackError!BodyCompressionT {
        var t = BodyCompressionT{};
        try BodyCompressionT.UnpackTo(rcv, &t, __pack_opts);
        return t;
    }

    pub fn deinit(self: *BodyCompressionT, allocator: std.mem.Allocator) void {
        _ = .{ self, allocator };
    }
};

pub const BodyCompression = struct {
    _tab: fb.Table,

    pub fn GetRootAs(buf: []u8, offset: u32) BodyCompression {
        const n = fb.encode.read(u32, buf[offset..]);
        return BodyCompression.init(buf, n + offset);
    }

    pub fn GetSizePrefixedRootAs(buf: []u8, offset: u32) BodyCompression {
        const n = fb.encode.read(u32, buf[offset + fb.Builder.size_u32 ..]);
        return BodyCompression.init(buf, n + offset + fb.Builder.size_u32);
    }

    pub fn init(bytes: []u8, pos: u32) BodyCompression {
        return .{ ._tab = .{ .bytes = bytes, .pos = pos } };
    }

    pub fn Table(x: BodyCompression) fb.Table {
        return x._tab;
    }

    /// Compressor library.
    /// For LZ4_FRAME, each compressed buffer must consist of a single frame.
    pub fn Codec(rcv: BodyCompression) CompressionType {
        const o = rcv._tab.offset(4);
        if (o != 0) {
            return rcv._tab.read(CompressionType, o + rcv._tab.pos);
        }
        return @intToEnum(CompressionType, 0);
    }

    pub fn MutateCodec(rcv: BodyCompression, n: CompressionType) bool {
        return rcv._tab.mutateSlot(CompressionType, 4, n);
    }

    /// Indicates the way the record batch body was compressed
    pub fn Method(rcv: BodyCompression) BodyCompressionMethod {
        const o = rcv._tab.offset(6);
        if (o != 0) {
            return rcv._tab.read(BodyCompressionMethod, o + rcv._tab.pos);
        }
        return @intToEnum(BodyCompressionMethod, 0);
    }

    pub fn MutateMethod(rcv: BodyCompression, n: BodyCompressionMethod) bool {
        return rcv._tab.mutateSlot(BodyCompressionMethod, 6, n);
    }

    pub fn Start(__builder: *Builder) !void {
        try __builder.startObject(2);
    }
    pub fn AddCodec(__builder: *Builder, codec: CompressionType) !void {
        try __builder.prependSlot(CompressionType, 0, codec, @intToEnum(CompressionType, 0));
    }

    pub fn AddMethod(__builder: *Builder, method: BodyCompressionMethod) !void {
        try __builder.prependSlot(BodyCompressionMethod, 1, method, @intToEnum(BodyCompressionMethod, 0));
    }

    pub fn End(__builder: *Builder) !u32 {
        return __builder.endObject();
    }

    pub fn Unpack(rcv: BodyCompression, __pack_opts: fb.common.PackOptions) !BodyCompressionT {
        return BodyCompressionT.Unpack(rcv, __pack_opts);
    }
    pub fn FinishBuffer(__builder: *Builder, root: u32) !void {
        return __builder.Finish(root);
    }

    pub fn FinishSizePrefixedBuffer(__builder: *Builder, root: u32) !void {
        return __builder.FinishSizePrefixed(root);
    }
};
