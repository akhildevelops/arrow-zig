//!
//! generated by flatc-zig
//! binary:     src/gen/format/Schema.bfbs
//! schema:     format/Schema.fbs
//! file ident: //Schema.fbs
//! typename    DictionaryEncoding
//!

const std = @import("std");
const fb = @import("flatbufferz");
const Builder = fb.Builder;

const DictionaryKind = @import("DictionaryKind.fb.zig").DictionaryKind;
const Int = @import("Int.fb.zig").Int;
const IntT = @import("Int.fb.zig").IntT;

pub const DictionaryEncodingT = struct {
    /// The known dictionary id in the application where this data is used. In
    /// the file or streaming formats, the dictionary ids are found in the
    /// DictionaryBatch messages
    id: i64 = 0,
    /// The dictionary indices are constrained to be non-negative integers. If
    /// this field is null, the indices must be signed int32. To maximize
    /// cross-language compatibility and performance, implementations are
    /// recommended to prefer signed integer types over unsigned integer types
    /// and to avoid uint64 indices unless they are required by an application.
    indexType: ?*IntT = null,
    /// By default, dictionaries are not ordered, or the order does not have
    /// semantic meaning. In some statistical, applications, dictionary-encoding
    /// is used to represent ordered categorical data, and we provide a way to
    /// preserve that metadata here
    isOrdered: bool = false,
    dictionaryKind: DictionaryKind = @intToEnum(DictionaryKind, 0),

    pub fn Pack(rcv: DictionaryEncodingT, __builder: *Builder, __pack_opts: fb.common.PackOptions) fb.common.PackError!u32 {
        _ = .{__pack_opts};
        var __tmp_offsets = std.ArrayListUnmanaged(u32){};
        defer if (__pack_opts.allocator) |alloc| __tmp_offsets.deinit(alloc);
        const indexType_off = if (rcv.indexType) |x| try x.Pack(__builder, __pack_opts) else 0;

        try DictionaryEncoding.Start(__builder);
        try DictionaryEncoding.AddId(__builder, rcv.id);
        try DictionaryEncoding.AddIndexType(__builder, indexType_off);
        try DictionaryEncoding.AddIsOrdered(__builder, rcv.isOrdered);
        try DictionaryEncoding.AddDictionaryKind_(__builder, rcv.dictionaryKind);
        return DictionaryEncoding.End(__builder);
    }

    pub fn UnpackTo(rcv: DictionaryEncoding, t: *DictionaryEncodingT, __pack_opts: fb.common.PackOptions) !void {
        _ = .{__pack_opts};
        t.id = rcv.Id();

        if (rcv.IndexType()) |x| {
            if (t.indexType == null) {
                t.indexType = try __pack_opts.allocator.?.create(IntT);
                t.indexType.?.* = .{};
            }
            try IntT.UnpackTo(x, t.indexType.?, __pack_opts);
        }

        t.isOrdered = rcv.IsOrdered();

        t.dictionaryKind = rcv.DictionaryKind_();
    }

    pub fn Unpack(rcv: DictionaryEncoding, __pack_opts: fb.common.PackOptions) fb.common.PackError!DictionaryEncodingT {
        var t = DictionaryEncodingT{};
        try DictionaryEncodingT.UnpackTo(rcv, &t, __pack_opts);
        return t;
    }

    pub fn deinit(self: *DictionaryEncodingT, allocator: std.mem.Allocator) void {
        _ = .{ self, allocator };
        if (self.indexType) |x| {
            x.deinit(allocator);
            allocator.destroy(x);
        }
    }
};

pub const DictionaryEncoding = struct {
    _tab: fb.Table,

    pub fn GetRootAs(buf: []u8, offset: u32) DictionaryEncoding {
        const n = fb.encode.read(u32, buf[offset..]);
        return DictionaryEncoding.init(buf, n + offset);
    }

    pub fn GetSizePrefixedRootAs(buf: []u8, offset: u32) DictionaryEncoding {
        const n = fb.encode.read(u32, buf[offset + fb.Builder.size_u32 ..]);
        return DictionaryEncoding.init(buf, n + offset + fb.Builder.size_u32);
    }

    pub fn init(bytes: []u8, pos: u32) DictionaryEncoding {
        return .{ ._tab = .{ .bytes = bytes, .pos = pos } };
    }

    pub fn Table(x: DictionaryEncoding) fb.Table {
        return x._tab;
    }

    /// The known dictionary id in the application where this data is used. In
    /// the file or streaming formats, the dictionary ids are found in the
    /// DictionaryBatch messages
    pub fn Id(rcv: DictionaryEncoding) i64 {
        const o = rcv._tab.offset(4);
        if (o != 0) {
            return rcv._tab.read(i64, o + rcv._tab.pos);
        }
        return 0;
    }

    pub fn MutateId(rcv: DictionaryEncoding, n: i64) bool {
        return rcv._tab.mutateSlot(i64, 4, n);
    }

    /// The dictionary indices are constrained to be non-negative integers. If
    /// this field is null, the indices must be signed int32. To maximize
    /// cross-language compatibility and performance, implementations are
    /// recommended to prefer signed integer types over unsigned integer types
    /// and to avoid uint64 indices unless they are required by an application.
    pub fn IndexType(rcv: DictionaryEncoding) ?Int {
        const o = rcv._tab.offset(6);
        if (o != 0) {
            const x = rcv._tab.indirect(o + rcv._tab.pos);
            return Int.init(rcv._tab.bytes, x);
        }
        return null;
    }

    /// By default, dictionaries are not ordered, or the order does not have
    /// semantic meaning. In some statistical, applications, dictionary-encoding
    /// is used to represent ordered categorical data, and we provide a way to
    /// preserve that metadata here
    pub fn IsOrdered(rcv: DictionaryEncoding) bool {
        const o = rcv._tab.offset(8);
        if (o != 0) {
            return rcv._tab.read(bool, o + rcv._tab.pos);
        }
        return false;
    }

    pub fn MutateIsOrdered(rcv: DictionaryEncoding, n: bool) bool {
        return rcv._tab.mutateSlot(bool, 8, n);
    }

    pub fn DictionaryKind_(rcv: DictionaryEncoding) DictionaryKind {
        const o = rcv._tab.offset(10);
        if (o != 0) {
            return rcv._tab.read(DictionaryKind, o + rcv._tab.pos);
        }
        return @intToEnum(DictionaryKind, 0);
    }

    pub fn MutateDictionaryKind_(rcv: DictionaryEncoding, n: DictionaryKind) bool {
        return rcv._tab.mutateSlot(DictionaryKind, 10, n);
    }

    pub fn Start(__builder: *Builder) !void {
        try __builder.startObject(4);
    }
    pub fn AddId(__builder: *Builder, id: i64) !void {
        try __builder.prependSlot(i64, 0, id, 0);
    }

    pub fn AddIndexType(__builder: *Builder, indexType: u32) !void {
        try __builder.prependSlotUOff(1, indexType, 0);
    }

    pub fn AddIsOrdered(__builder: *Builder, isOrdered: bool) !void {
        try __builder.prependSlot(bool, 2, isOrdered, false);
    }

    pub fn AddDictionaryKind_(__builder: *Builder, dictionaryKind: DictionaryKind) !void {
        try __builder.prependSlot(DictionaryKind, 3, dictionaryKind, @intToEnum(DictionaryKind, 0));
    }

    pub fn End(__builder: *Builder) !u32 {
        return __builder.endObject();
    }

    pub fn Unpack(rcv: DictionaryEncoding, __pack_opts: fb.common.PackOptions) !DictionaryEncodingT {
        return DictionaryEncodingT.Unpack(rcv, __pack_opts);
    }
    pub fn FinishBuffer(__builder: *Builder, root: u32) !void {
        return __builder.Finish(root);
    }

    pub fn FinishSizePrefixedBuffer(__builder: *Builder, root: u32) !void {
        return __builder.FinishSizePrefixed(root);
    }
};
