//!
//! generated by flatc-zig
//! binary:     src/gen/format/Schema.bfbs
//! schema:     format/Schema.fbs
//! file ident: //Schema.fbs
//! typename    KeyValue
//!

const std = @import("std");
const fb = @import("flatbufferz");
const Builder = fb.Builder;

/// ----------------------------------------------------------------------
/// user defined key value pairs to add custom metadata to arrow
/// key namespacing is the responsibility of the user
pub const KeyValueT = struct {
    key: []const u8 = "",
    value: []const u8 = "",

    pub fn Pack(rcv: KeyValueT, __builder: *Builder, __pack_opts: fb.common.PackOptions) fb.common.PackError!u32 {
        _ = .{__pack_opts};
        var __tmp_offsets = std.ArrayListUnmanaged(u32){};
        defer if (__pack_opts.allocator) |alloc| __tmp_offsets.deinit(alloc);
        const key_off = if (rcv.key.len != 0) try __builder.createString(rcv.key) else 0;

        const value_off = if (rcv.value.len != 0) try __builder.createString(rcv.value) else 0;

        try KeyValue.Start(__builder);
        try KeyValue.AddKey(__builder, key_off);
        try KeyValue.AddValue(__builder, value_off);
        return KeyValue.End(__builder);
    }

    pub fn UnpackTo(rcv: KeyValue, t: *KeyValueT, __pack_opts: fb.common.PackOptions) !void {
        _ = .{__pack_opts};
        t.key = rcv.Key();

        t.value = rcv.Value();
    }

    pub fn Unpack(rcv: KeyValue, __pack_opts: fb.common.PackOptions) fb.common.PackError!KeyValueT {
        var t = KeyValueT{};
        try KeyValueT.UnpackTo(rcv, &t, __pack_opts);
        return t;
    }

    pub fn deinit(self: *KeyValueT, allocator: std.mem.Allocator) void {
        _ = .{ self, allocator };
        // TODO __pack_opts.dupe_strings
        // if(self.key.len > 0) allocator.free(self.key);
        // TODO __pack_opts.dupe_strings
        // if(self.value.len > 0) allocator.free(self.value);
    }
};

pub const KeyValue = struct {
    _tab: fb.Table,

    pub fn GetRootAs(buf: []u8, offset: u32) KeyValue {
        const n = fb.encode.read(u32, buf[offset..]);
        return KeyValue.init(buf, n + offset);
    }

    pub fn GetSizePrefixedRootAs(buf: []u8, offset: u32) KeyValue {
        const n = fb.encode.read(u32, buf[offset + fb.Builder.size_u32 ..]);
        return KeyValue.init(buf, n + offset + fb.Builder.size_u32);
    }

    pub fn init(bytes: []u8, pos: u32) KeyValue {
        return .{ ._tab = .{ .bytes = bytes, .pos = pos } };
    }

    pub fn Table(x: KeyValue) fb.Table {
        return x._tab;
    }

    pub fn Key(rcv: KeyValue) []const u8 {
        const o = rcv._tab.offset(4);
        if (o != 0) {
            return rcv._tab.byteVector(o + rcv._tab.pos);
        }
        return "";
    }

    pub fn Value(rcv: KeyValue) []const u8 {
        const o = rcv._tab.offset(6);
        if (o != 0) {
            return rcv._tab.byteVector(o + rcv._tab.pos);
        }
        return "";
    }

    pub fn Start(__builder: *Builder) !void {
        try __builder.startObject(2);
    }
    pub fn AddKey(__builder: *Builder, key: u32) !void {
        try __builder.prependSlotUOff(0, key, 0);
    }

    pub fn AddValue(__builder: *Builder, value: u32) !void {
        try __builder.prependSlotUOff(1, value, 0);
    }

    pub fn End(__builder: *Builder) !u32 {
        return __builder.endObject();
    }

    pub fn Unpack(rcv: KeyValue, __pack_opts: fb.common.PackOptions) !KeyValueT {
        return KeyValueT.Unpack(rcv, __pack_opts);
    }
    pub fn FinishBuffer(__builder: *Builder, root: u32) !void {
        return __builder.Finish(root);
    }

    pub fn FinishSizePrefixedBuffer(__builder: *Builder, root: u32) !void {
        return __builder.FinishSizePrefixed(root);
    }
};
