//!
//! generated by flatc-zig
//! binary:     src/gen/format/Schema.bfbs
//! schema:     format/Schema.fbs
//! file ident: //Schema.fbs
//! typename    Union
//!

const std = @import("std");
const fb = @import("flatbufferz");
const Builder = fb.Builder;

const UnionMode = @import("UnionMode.fb.zig").UnionMode;

/// A union is a complex type with children in Field
/// By default ids in the type vector refer to the offsets in the children
/// optionally typeIds provides an indirection between the child offset and the type id
/// for each child `typeIds[offset]` is the id used in the type vector
pub const UnionT = struct {
    mode: UnionMode = @intToEnum(UnionMode, 0),
    typeIds: std.ArrayListUnmanaged(i32) = .{},

    pub fn Pack(rcv: UnionT, __builder: *Builder, __pack_opts: fb.common.PackOptions) fb.common.PackError!u32 {
        _ = .{__pack_opts};
        var __tmp_offsets = std.ArrayListUnmanaged(u32){};
        defer if (__pack_opts.allocator) |alloc| __tmp_offsets.deinit(alloc);
        var typeIds_off: u32 = 0;
        if (rcv.typeIds.items.len != 0) {
            const typeIds_len = @intCast(i32, rcv.typeIds.items.len);
            _ = try Union.StartTypeIdsVector(__builder, typeIds_len);
            {
                var j = typeIds_len - 1;
                while (j >= 0) : (j -= 1) {
                    try __builder.prepend(i32, rcv.typeIds.items[@bitCast(u32, j)]);
                }
                typeIds_off = try __builder.endVector(@bitCast(u32, typeIds_len));
            }
        }

        try Union.Start(__builder);
        try Union.AddMode(__builder, rcv.mode);
        try Union.AddTypeIds(__builder, typeIds_off);
        return Union.End(__builder);
    }

    pub fn UnpackTo(rcv: Union, t: *UnionT, __pack_opts: fb.common.PackOptions) !void {
        _ = .{__pack_opts};
        t.mode = rcv.Mode();

        const typeIds_len = rcv.TypeIdsLen();
        t.typeIds = try std.ArrayListUnmanaged(i32).initCapacity(__pack_opts.allocator.?, @bitCast(u32, typeIds_len));
        t.typeIds.expandToCapacity();
        {
            var j: u32 = 0;
            while (j < typeIds_len) : (j += 1) {
                t.typeIds.items[j] = rcv.TypeIds(j).?;
            }
        }
    }

    pub fn Unpack(rcv: Union, __pack_opts: fb.common.PackOptions) fb.common.PackError!UnionT {
        var t = UnionT{};
        try UnionT.UnpackTo(rcv, &t, __pack_opts);
        return t;
    }

    pub fn deinit(self: *UnionT, allocator: std.mem.Allocator) void {
        _ = .{ self, allocator };
        self.typeIds.deinit(allocator);
    }
};

pub const Union = struct {
    _tab: fb.Table,

    pub fn GetRootAs(buf: []u8, offset: u32) Union {
        const n = fb.encode.read(u32, buf[offset..]);
        return Union.init(buf, n + offset);
    }

    pub fn GetSizePrefixedRootAs(buf: []u8, offset: u32) Union {
        const n = fb.encode.read(u32, buf[offset + fb.Builder.size_u32 ..]);
        return Union.init(buf, n + offset + fb.Builder.size_u32);
    }

    pub fn init(bytes: []u8, pos: u32) Union {
        return .{ ._tab = .{ .bytes = bytes, .pos = pos } };
    }

    pub fn Table(x: Union) fb.Table {
        return x._tab;
    }

    pub fn Mode(rcv: Union) UnionMode {
        const o = rcv._tab.offset(4);
        if (o != 0) {
            return rcv._tab.read(UnionMode, o + rcv._tab.pos);
        }
        return @intToEnum(UnionMode, 0);
    }

    pub fn MutateMode(rcv: Union, n: UnionMode) bool {
        return rcv._tab.mutateSlot(UnionMode, 4, n);
    }

    pub fn TypeIds(rcv: Union, j: usize) ?i32 {
        const o = rcv._tab.offset(6);
        if (o != 0) {
            const a = rcv._tab.vector(o);
            return rcv._tab.read(i32, a + @intCast(u32, j) * 4);
        }
        return 0;
    }

    pub fn TypeIdsLen(rcv: Union) u32 {
        const o = rcv._tab.offset(6);
        if (o != 0) {
            return rcv._tab.vectorLen(o);
        }
        return 0;
    }

    pub fn MutateTypeIds(rcv: Union, j: usize, n: i32) bool {
        const o = rcv._tab.offset(6);
        if (o != 0) {
            const a = rcv._tab.vector(o);
            return rcv._tab.mutate(i32, a + @intCast(u32, j) * 4, n);
        }
        return false;
    }

    pub fn Start(__builder: *Builder) !void {
        try __builder.startObject(2);
    }
    pub fn AddMode(__builder: *Builder, mode: UnionMode) !void {
        try __builder.prependSlot(UnionMode, 0, mode, @intToEnum(UnionMode, 0));
    }

    pub fn AddTypeIds(__builder: *Builder, typeIds: u32) !void {
        try __builder.prependSlotUOff(1, typeIds, 0);
    }

    pub fn StartTypeIdsVector(__builder: *Builder, num_elems: i32) !u32 {
        return __builder.startVector(4, num_elems, 4);
    }
    pub fn End(__builder: *Builder) !u32 {
        return __builder.endObject();
    }

    pub fn Unpack(rcv: Union, __pack_opts: fb.common.PackOptions) !UnionT {
        return UnionT.Unpack(rcv, __pack_opts);
    }
    pub fn FinishBuffer(__builder: *Builder, root: u32) !void {
        return __builder.Finish(root);
    }

    pub fn FinishSizePrefixedBuffer(__builder: *Builder, root: u32) !void {
        return __builder.FinishSizePrefixed(root);
    }
};
