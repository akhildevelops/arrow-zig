//!
//! generated by flatc-zig
//! binary:     gen/format/Schema.bfbs
//! schema:     format/Schema.fbs
//! file ident: //Schema.fbs
//! typename    Buffer
//!

const std = @import("std");
const fb = @import("flatbufferz");
const Builder = fb.Builder;

/// ----------------------------------------------------------------------
/// A Buffer represents a single contiguous memory segment
pub const BufferT = struct {
    /// The relative offset into the shared memory page where the bytes for this
    /// buffer starts
    offset: i64 = 0,
    /// The absolute length (in bytes) of the memory buffer. The memory is found
    /// from offset (inclusive) to offset + length (non-inclusive). When building
    /// messages using the encapsulated IPC message, padding bytes may be written
    /// after a buffer, but such padding bytes do not need to be accounted for in
    /// the size here.
    length: i64 = 0,

    pub fn Pack(rcv: BufferT, __builder: *Builder, __pack_opts: fb.common.PackOptions) !u32 {
        _ = .{__pack_opts};
        return Buffer.Create(__builder, rcv.offset, rcv.length);
    }
    pub fn UnpackTo(rcv: Buffer, t: *BufferT, __pack_opts: fb.common.PackOptions) !void {
        _ = .{__pack_opts};
        t.offset = rcv.Offset();
        t.length = rcv.Length();
    }

    pub fn Unpack(rcv: Buffer, __pack_opts: fb.common.PackOptions) !BufferT {
        var t = BufferT{};
        try BufferT.UnpackTo(rcv, &t, __pack_opts);
        return t;
    }

    pub fn deinit(self: *BufferT, allocator: std.mem.Allocator) void {
        _ = .{ self, allocator };
    }
};

pub const Buffer = struct {
    _tab: fb.Struct,

    pub fn init(bytes: []u8, pos: u32) Buffer {
        return .{ ._tab = .{ ._tab = .{ .bytes = bytes, .pos = pos } } };
    }

    pub fn Table(x: Buffer) fb.Table {
        return x._tab._tab;
    }

    /// The relative offset into the shared memory page where the bytes for this
    /// buffer starts
    pub fn Offset(rcv: Buffer) i64 {
        return rcv._tab.read(i64, rcv._tab._tab.pos + 0);
    }
    pub fn MutateOffset(rcv: Buffer, n: i64) bool {
        return rcv._tab._tab.mutate(i64, rcv._tab._tab.pos + 0, n);
    }

    /// The absolute length (in bytes) of the memory buffer. The memory is found
    /// from offset (inclusive) to offset + length (non-inclusive). When building
    /// messages using the encapsulated IPC message, padding bytes may be written
    /// after a buffer, but such padding bytes do not need to be accounted for in
    /// the size here.
    pub fn Length(rcv: Buffer) i64 {
        return rcv._tab.read(i64, rcv._tab._tab.pos + 8);
    }
    pub fn MutateLength(rcv: Buffer, n: i64) bool {
        return rcv._tab._tab.mutate(i64, rcv._tab._tab.pos + 8, n);
    }

    pub fn Create(__builder: *Builder, offset: i64, length: i64) !u32 {
        try __builder.prep(8, 16);
        try __builder.prepend(i64, length);
        try __builder.prepend(i64, offset);
        return __builder.offset();
    }
    pub fn Unpack(rcv: Buffer, __pack_opts: fb.common.PackOptions) !BufferT {
        return BufferT.Unpack(rcv, __pack_opts);
    }
    pub fn FinishBuffer(__builder: *Builder, root: u32) !void {
        return __builder.Finish(root);
    }

    pub fn FinishSizePrefixedBuffer(__builder: *Builder, root: u32) !void {
        return __builder.FinishSizePrefixed(root);
    }
};
