//!
//! generated by flatc-zig
//! binary:     src/ipc/gen/format/Message.bfbs
//! schema:     format/Message.fbs
//! file ident: //Message.fbs
//! typename    DictionaryBatch
//!

const std = @import("std");
const fb = @import("flatbufferz");
const Builder = fb.Builder;

const RecordBatch = @import("RecordBatch.fb.zig").RecordBatch;
const RecordBatchT = @import("RecordBatch.fb.zig").RecordBatchT;

/// For sending dictionary encoding information. Any Field can be
/// dictionary-encoded, but in this case none of its children may be
/// dictionary-encoded.
/// There is one vector / column per dictionary, but that vector / column
/// may be spread across multiple dictionary batches by using the isDelta
/// flag
pub const DictionaryBatchT = struct {
    id: i64 = 0,
    data: ?*RecordBatchT = null,
    /// If isDelta is true the values in the dictionary are to be appended to a
    /// dictionary with the indicated id. If isDelta is false this dictionary
    /// should replace the existing dictionary.
    isDelta: bool = false,

    pub fn Pack(rcv: DictionaryBatchT, __builder: *Builder, __pack_opts: fb.common.PackOptions) fb.common.PackError!u32 {
        _ = .{__pack_opts};
        var __tmp_offsets = std.ArrayListUnmanaged(u32){};
        defer if (__pack_opts.allocator) |alloc| __tmp_offsets.deinit(alloc);
        const data_off = if (rcv.data) |x| try x.Pack(__builder, __pack_opts) else 0;

        try DictionaryBatch.Start(__builder);
        try DictionaryBatch.AddId(__builder, rcv.id);
        try DictionaryBatch.AddData(__builder, data_off);
        try DictionaryBatch.AddIsDelta(__builder, rcv.isDelta);
        return DictionaryBatch.End(__builder);
    }

    pub fn UnpackTo(rcv: DictionaryBatch, t: *DictionaryBatchT, __pack_opts: fb.common.PackOptions) !void {
        _ = .{__pack_opts};
        t.id = rcv.Id();

        if (rcv.Data()) |x| {
            if (t.data == null) {
                t.data = try __pack_opts.allocator.?.create(RecordBatchT);
                t.data.?.* = .{};
            }
            try RecordBatchT.UnpackTo(x, t.data.?, __pack_opts);
        }

        t.isDelta = rcv.IsDelta();
    }

    pub fn Unpack(rcv: DictionaryBatch, __pack_opts: fb.common.PackOptions) fb.common.PackError!DictionaryBatchT {
        var t = DictionaryBatchT{};
        try DictionaryBatchT.UnpackTo(rcv, &t, __pack_opts);
        return t;
    }

    pub fn deinit(self: *DictionaryBatchT, allocator: std.mem.Allocator) void {
        _ = .{ self, allocator };
        if (self.data) |x| {
            x.deinit(allocator);
            allocator.destroy(x);
        }
    }
};

pub const DictionaryBatch = struct {
    _tab: fb.Table,

    pub fn GetRootAs(buf: []u8, offset: u32) DictionaryBatch {
        const n = fb.encode.read(u32, buf[offset..]);
        return DictionaryBatch.init(buf, n + offset);
    }

    pub fn GetSizePrefixedRootAs(buf: []u8, offset: u32) DictionaryBatch {
        const n = fb.encode.read(u32, buf[offset + fb.Builder.size_u32 ..]);
        return DictionaryBatch.init(buf, n + offset + fb.Builder.size_u32);
    }

    pub fn init(bytes: []u8, pos: u32) DictionaryBatch {
        return .{ ._tab = .{ .bytes = bytes, .pos = pos } };
    }

    pub fn Table(x: DictionaryBatch) fb.Table {
        return x._tab;
    }

    pub fn Id(rcv: DictionaryBatch) i64 {
        const o = rcv._tab.offset(4);
        if (o != 0) {
            return rcv._tab.read(i64, o + rcv._tab.pos);
        }
        return 0;
    }

    pub fn MutateId(rcv: DictionaryBatch, n: i64) bool {
        return rcv._tab.mutateSlot(i64, 4, n);
    }

    pub fn Data(rcv: DictionaryBatch) ?RecordBatch {
        const o = rcv._tab.offset(6);
        if (o != 0) {
            const x = rcv._tab.indirect(o + rcv._tab.pos);
            return RecordBatch.init(rcv._tab.bytes, x);
        }
        return null;
    }

    /// If isDelta is true the values in the dictionary are to be appended to a
    /// dictionary with the indicated id. If isDelta is false this dictionary
    /// should replace the existing dictionary.
    pub fn IsDelta(rcv: DictionaryBatch) bool {
        const o = rcv._tab.offset(8);
        if (o != 0) {
            return rcv._tab.read(bool, o + rcv._tab.pos);
        }
        return false;
    }

    pub fn MutateIsDelta(rcv: DictionaryBatch, n: bool) bool {
        return rcv._tab.mutateSlot(bool, 8, n);
    }

    pub fn Start(__builder: *Builder) !void {
        try __builder.startObject(3);
    }
    pub fn AddId(__builder: *Builder, id: i64) !void {
        try __builder.prependSlot(i64, 0, id, 0);
    }

    pub fn AddData(__builder: *Builder, data: u32) !void {
        try __builder.prependSlotUOff(1, data, 0);
    }

    pub fn AddIsDelta(__builder: *Builder, isDelta: bool) !void {
        try __builder.prependSlot(bool, 2, isDelta, false);
    }

    pub fn End(__builder: *Builder) !u32 {
        return __builder.endObject();
    }

    pub fn Unpack(rcv: DictionaryBatch, __pack_opts: fb.common.PackOptions) !DictionaryBatchT {
        return DictionaryBatchT.Unpack(rcv, __pack_opts);
    }
    pub fn FinishBuffer(__builder: *Builder, root: u32) !void {
        return __builder.Finish(root);
    }

    pub fn FinishSizePrefixedBuffer(__builder: *Builder, root: u32) !void {
        return __builder.FinishSizePrefixed(root);
    }
};
