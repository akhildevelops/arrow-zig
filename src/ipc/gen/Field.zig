//! generated by flatc-zig from Schema.fbs

const flatbuffers = @import("flatbuffers");
const std = @import("std");
const types = @import("lib.zig");
const tags = @import("../../tags.zig");
const shared = @import("../shared.zig");

const log = shared.log;
const IpcError = shared.IpcError;

/// ----------------------------------------------------------------------
/// A field represents a named column in a record / row batch or child of a
/// nested type.
pub const Field = struct {
    /// Name is not required, in i.e. a List
    name: [:0]const u8,
    /// Whether or not this field can contain nulls. Should be true in general.
    nullable: bool = false,
    /// This is the type of the decoded value if the field is dictionary encoded.
    type: types.Type,
    /// Present only if the field is dictionary encoded.
    dictionary: ?types.DictionaryEncoding = null,
    /// children apply only to nested data types like Struct, List and Union. For
    /// primitive types children will have length 0.
    children: []types.Field,
    /// User-defined metadata
    custom_metadata: []types.KeyValue,

    const Self = @This();

    pub fn init(allocator: std.mem.Allocator, packed_: PackedField) flatbuffers.Error!Self {
        const name_ = try allocator.dupeZ(u8, try packed_.name());
        errdefer {
            allocator.free(name_);
        }
        const @"type" = try types.Type.init(allocator, try packed_.type());
        errdefer {
            @"type".deinit(allocator);
        }
        const dictionary_ = if (try packed_.dictionary()) |d| try types.DictionaryEncoding.init(d) else null;
        errdefer {}
        const children_ = try flatbuffers.unpackVector(allocator, types.Field, packed_, "children");
        errdefer {
            for (children_) |c| c.deinit(allocator);
            allocator.free(children_);
        }
        const custom_metadata_ = try flatbuffers.unpackVector(allocator, types.KeyValue, packed_, "customMetadata");
        errdefer {
            for (custom_metadata_) |c| c.deinit(allocator);
            allocator.free(custom_metadata_);
        }
        return .{
            .name = name_,
            .nullable = try packed_.nullable(),
            .type = @"type",
            .dictionary = dictionary_,
            .children = children_,
            .custom_metadata = custom_metadata_,
        };
    }

    pub fn deinit(self: Self, allocator: std.mem.Allocator) void {
        allocator.free(self.name);
        self.type.deinit(allocator);
        for (self.children) |c| c.deinit(allocator);
        allocator.free(self.children);
        for (self.custom_metadata) |c| c.deinit(allocator);
        allocator.free(self.custom_metadata);
    }

    pub fn pack(self: Self, builder: *flatbuffers.Builder) flatbuffers.Error!u32 {
        const field_offsets = .{
            .name = try builder.prependString(self.name),
            .type = try self.type.pack(builder),
            .dictionary = if (self.dictionary) |d| try d.pack(builder) else 0,
            .children = try builder.prependVectorOffsets(types.Field, self.children),
            .custom_metadata = try builder.prependVectorOffsets(types.KeyValue, self.custom_metadata),
        };

        try builder.startTable();
        try builder.appendTableFieldOffset(field_offsets.name);
        try builder.appendTableField(bool, self.nullable);
        try builder.appendTableField(types.PackedType.Tag, self.type);
        try builder.appendTableFieldOffset(field_offsets.type);
        try builder.appendTableFieldOffset(field_offsets.dictionary);
        try builder.appendTableFieldOffset(field_offsets.children);
        try builder.appendTableFieldOffset(field_offsets.custom_metadata);
        return builder.endTable();
    }

    fn print2(self: Self, indent_level: usize) void {
        for (0..indent_level) |_| std.debug.print("\t", .{});
        std.debug.print("{s} {s}{any}\n", .{ self.name, if (self.nullable) "?" else "", self.type });
        for (self.children) |c| c.print2(indent_level + 1);
    }

    pub fn print(self: Self) void {
        self.print2(0);
    }

    pub fn toTag(self: Self) IpcError!tags.Tag {
        return switch (self.type) {
            .null => .Null,
            .int => |i| .{ .Int = .{
                .nullable = self.nullable,
                .signed = i.is_signed,
                .bit_width = switch (i.bit_width) {
                    8 => ._8,
                    16 => ._16,
                    32 => ._32,
                    64 => ._64,
                    else => |w| {
                        log.err("int field {s} invalid bit width {d}", .{ self.name, w });
                        return IpcError.InvalidBitWidth;
                    },
                },
            } },
            .floating_point => |f| .{ .Float = .{ .nullable = self.nullable, .bit_width = switch (f.precision) {
                .half => ._16,
                .single => ._32,
                .double => ._64,
            } } },
            .binary => .{ .Binary = .{ .nullable = self.nullable, .large = false, .utf8 = false } },
            .large_binary => .{ .Binary = .{ .nullable = self.nullable, .large = true, .utf8 = false } },
            .utf8 => .{ .Binary = .{ .nullable = self.nullable, .large = false, .utf8 = true } },
            .large_utf8 => .{ .Binary = .{ .nullable = self.nullable, .large = true, .utf8 = true } },
            .bool => .{ .Bool = .{ .nullable = self.nullable } },
            // .Decimal: ?*DecimalT,
            .date => |d| .{ .Date = .{
                .nullable = self.nullable,
                .unit = switch (d.unit) {
                    .day => .day,
                    .millisecond => .millisecond,
                },
            } },
            .time => |t| .{ .Time = .{
                .nullable = self.nullable,
                .unit = switch (t.unit) {
                    .second => .second,
                    .millisecond => .millisecond,
                    .microsecond => .microsecond,
                    .nanosecond => .nanosecond,
                },
            } },
            .timestamp => |ts| .{ .Timestamp = .{
                .nullable = self.nullable,
                .unit = switch (ts.unit) {
                    .second => .second,
                    .millisecond => .millisecond,
                    .microsecond => .microsecond,
                    .nanosecond => .nanosecond,
                },
                .timezone = ts.timezone,
            } },
            .duration => |d| .{ .Duration = .{
                .nullable = self.nullable,
                .unit = switch (d.unit) {
                    .second => .second,
                    .millisecond => .millisecond,
                    .microsecond => .microsecond,
                    .nanosecond => .nanosecond,
                },
            } },
            .interval => |i| .{ .Interval = .{
                .nullable = self.nullable,
                .unit = switch (i.unit) {
                    .year_month => .year_month,
                    .day_time => .day_time,
                    .month_day_nano => .month_day_nanosecond,
                },
            } },
            .list => .{ .List = .{ .nullable = self.nullable, .large = false } },
            .large_list => .{ .List = .{ .nullable = self.nullable, .large = true } },
            .struct_ => .{ .Struct = .{ .nullable = self.nullable } },
            .@"union" => |u| .{ .Union = .{
                .nullable = self.nullable,
                .dense = switch (u.mode) {
                    .dense => true,
                    .sparse => false,
                },
            } },
            .fixed_size_binary => |b| .{ .FixedBinary = .{
                .nullable = self.nullable,
                .fixed_len = b.byte_width,
            } },
            .fixed_size_list => |f| .{ .FixedList = .{
                .nullable = self.nullable,
                .fixed_len = f.list_size,
            } },
            .map => .{ .Map = .{ .nullable = self.nullable } },
            // .RunEndEncoded: ?*RunEndEncodedT,
            else => |t| {
                log.warn("field {s} unknown type {any}", .{ self.name, t });
                return IpcError.InvalidFieldTag;
            },
        };
    }

    pub fn toMaybeDictTag(self: Self) IpcError!tags.Tag {
        if (self.dictionary) |d| return try d.toTag();

        return try self.toTag();
    }

    pub fn nFields(self: Self) usize {
        var res: usize = 0;
        for (self.children) |field| res += 1 + field.nFields();
        return res;
    }

    pub fn nBuffers(self: Self) IpcError!usize {
        const tag = try toMaybeDictTag(self);
        var res: usize = tag.abiLayout().nBuffers();
        for (self.children) |field| res += try field.nBuffers();
        return res;
    }
};

/// ----------------------------------------------------------------------
/// A field represents a named column in a record / row batch or child of a
/// nested type.
pub const PackedField = struct {
    table: flatbuffers.Table,

    const Self = @This();

    pub fn init(size_prefixed_bytes: []u8) flatbuffers.Error!Self {
        return .{ .table = try flatbuffers.Table.init(size_prefixed_bytes) };
    }

    /// Name is not required, in i.e. a List
    pub fn name(self: Self) flatbuffers.Error![:0]const u8 {
        return self.table.readField([:0]const u8, 0);
    }

    /// Whether or not this field can contain nulls. Should be true in general.
    pub fn nullable(self: Self) flatbuffers.Error!bool {
        return self.table.readFieldWithDefault(bool, 1, false);
    }

    pub fn typeType(self: Self) flatbuffers.Error!types.PackedType.Tag {
        return self.table.readFieldWithDefault(types.PackedType.Tag, 2, .none);
    }

    /// This is the type of the decoded value if the field is dictionary encoded.
    pub fn @"type"(self: Self) flatbuffers.Error!types.PackedType {
        return switch (try self.typeType()) {
            inline else => |tag| {
                var result = @unionInit(types.PackedType, @tagName(tag), undefined);
                const field = &@field(result, @tagName(tag));
                field.* = try self.table.readField(@TypeOf(field.*), 3);
                return result;
            },
        };
    }

    /// Present only if the field is dictionary encoded.
    pub fn dictionary(self: Self) flatbuffers.Error!?types.PackedDictionaryEncoding {
        return self.table.readField(?types.PackedDictionaryEncoding, 4);
    }

    /// children apply only to nested data types like Struct, List and Union. For
    /// primitive types children will have length 0.
    pub fn childrenLen(self: Self) flatbuffers.Error!u32 {
        return self.table.readFieldVectorLen(5);
    }
    pub fn children(self: Self, index: usize) flatbuffers.Error!types.PackedField {
        return self.table.readFieldVectorItem(types.PackedField, 5, index);
    }

    /// User-defined metadata
    pub fn customMetadataLen(self: Self) flatbuffers.Error!u32 {
        return self.table.readFieldVectorLen(6);
    }
    pub fn customMetadata(self: Self, index: usize) flatbuffers.Error!types.PackedKeyValue {
        return self.table.readFieldVectorItem(types.PackedKeyValue, 6, index);
    }
};
