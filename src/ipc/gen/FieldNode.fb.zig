//!
//! generated by flatc-zig
//! binary:     src/ipc/gen/format/Message.bfbs
//! schema:     format/Message.fbs
//! file ident: //Message.fbs
//! typename    FieldNode
//!

const std = @import("std");
const fb = @import("flatbufferz");
const Builder = fb.Builder;

/// ----------------------------------------------------------------------
/// Data structures for describing a table row batch (a collection of
/// equal-length Arrow arrays)
/// Metadata about a field at some level of a nested type tree (but not
/// its children).
///
/// For example, a List<Int16> with values `[[1, 2, 3], null, [4], [5, 6], null]`
/// would have {length: 5, null_count: 2} for its List node, and {length: 6,
/// null_count: 0} for its Int16 node, as separate FieldNode structs
pub const FieldNodeT = struct {
    /// The number of value slots in the Arrow array at this level of a nested
    /// tree
    length: i64 = 0,
    /// The number of observed nulls. Fields with null_count == 0 may choose not
    /// to write their physical validity bitmap out as a materialized buffer,
    /// instead setting the length of the bitmap buffer to 0.
    null_count: i64 = 0,

    pub fn Pack(rcv: FieldNodeT, __builder: *Builder, __pack_opts: fb.common.PackOptions) !u32 {
        _ = .{__pack_opts};
        return FieldNode.Create(__builder, rcv.length, rcv.null_count);
    }
    pub fn UnpackTo(rcv: FieldNode, t: *FieldNodeT, __pack_opts: fb.common.PackOptions) !void {
        _ = .{__pack_opts};
        t.length = rcv.Length();
        t.null_count = rcv.NullCount();
    }

    pub fn Unpack(rcv: FieldNode, __pack_opts: fb.common.PackOptions) !FieldNodeT {
        var t = FieldNodeT{};
        try FieldNodeT.UnpackTo(rcv, &t, __pack_opts);
        return t;
    }

    pub fn deinit(self: *FieldNodeT, allocator: std.mem.Allocator) void {
        _ = .{ self, allocator };
    }
};

pub const FieldNode = struct {
    _tab: fb.Struct,

    pub fn init(bytes: []u8, pos: u32) FieldNode {
        return .{ ._tab = .{ ._tab = .{ .bytes = bytes, .pos = pos } } };
    }

    pub fn Table(x: FieldNode) fb.Table {
        return x._tab._tab;
    }

    /// The number of value slots in the Arrow array at this level of a nested
    /// tree
    pub fn Length(rcv: FieldNode) i64 {
        return rcv._tab.read(i64, rcv._tab._tab.pos + 0);
    }
    pub fn MutateLength(rcv: FieldNode, n: i64) bool {
        return rcv._tab._tab.mutate(i64, rcv._tab._tab.pos + 0, n);
    }

    /// The number of observed nulls. Fields with null_count == 0 may choose not
    /// to write their physical validity bitmap out as a materialized buffer,
    /// instead setting the length of the bitmap buffer to 0.
    pub fn NullCount(rcv: FieldNode) i64 {
        return rcv._tab.read(i64, rcv._tab._tab.pos + 8);
    }
    pub fn MutateNullCount(rcv: FieldNode, n: i64) bool {
        return rcv._tab._tab.mutate(i64, rcv._tab._tab.pos + 8, n);
    }

    pub fn Create(__builder: *Builder, length: i64, null_count: i64) !u32 {
        try __builder.prep(8, 16);
        try __builder.prepend(i64, null_count);
        try __builder.prepend(i64, length);
        return __builder.offset();
    }
    pub fn Unpack(rcv: FieldNode, __pack_opts: fb.common.PackOptions) !FieldNodeT {
        return FieldNodeT.Unpack(rcv, __pack_opts);
    }
    pub fn FinishBuffer(__builder: *Builder, root: u32) !void {
        return __builder.Finish(root);
    }

    pub fn FinishSizePrefixedBuffer(__builder: *Builder, root: u32) !void {
        return __builder.FinishSizePrefixed(root);
    }
};
