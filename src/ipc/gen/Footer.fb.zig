//!
//! generated by flatc-zig
//! binary:     gen/format/File.bfbs
//! schema:     format/File.fbs
//! file ident: //File.fbs
//! typename    Footer
//!

const std = @import("std");
const fb = @import("flatbufferz");
const Builder = fb.Builder;

const Schema = @import("Schema.fb.zig").Schema;
const SchemaT = @import("Schema.fb.zig").SchemaT;
const Block = @import("Block.fb.zig").Block;
const BlockT = @import("Block.fb.zig").BlockT;
const MetadataVersion = @import("MetadataVersion.fb.zig").MetadataVersion;
const KeyValue = @import("KeyValue.fb.zig").KeyValue;
const KeyValueT = @import("KeyValue.fb.zig").KeyValueT;

pub const __file_ident: fb.Builder.Fid = "".*;
pub const __file_ext = "";

/// ----------------------------------------------------------------------
/// Arrow File metadata
///
pub const FooterT = struct {
    version: MetadataVersion = @intToEnum(MetadataVersion, 0),
    schema: ?*SchemaT = null,
    dictionaries: std.ArrayListUnmanaged(BlockT) = .{},
    recordBatches: std.ArrayListUnmanaged(BlockT) = .{},
    /// User-defined metadata
    custom_metadata: std.ArrayListUnmanaged(KeyValueT) = .{},

    pub fn Pack(rcv: FooterT, __builder: *Builder, __pack_opts: fb.common.PackOptions) fb.common.PackError!u32 {
        _ = .{__pack_opts};
        var __tmp_offsets = std.ArrayListUnmanaged(u32){};
        defer if (__pack_opts.allocator) |alloc| __tmp_offsets.deinit(alloc);
        const schema_off = if (rcv.schema) |x| try x.Pack(__builder, __pack_opts) else 0;

        var dictionaries_off: u32 = 0;
        if (rcv.dictionaries.items.len != 0) {
            const dictionaries_len = @intCast(i32, rcv.dictionaries.items.len);
            _ = try Footer.StartDictionariesVector(__builder, dictionaries_len);
            {
                var j = dictionaries_len - 1;
                while (j >= 0) : (j -= 1) {
                    _ = try rcv.dictionaries.items[@bitCast(u32, j)].Pack(__builder, __pack_opts);
                }
                dictionaries_off = try __builder.endVector(@bitCast(u32, dictionaries_len));
            }
        }

        var recordBatches_off: u32 = 0;
        if (rcv.recordBatches.items.len != 0) {
            const recordBatches_len = @intCast(i32, rcv.recordBatches.items.len);
            _ = try Footer.StartRecordBatchesVector(__builder, recordBatches_len);
            {
                var j = recordBatches_len - 1;
                while (j >= 0) : (j -= 1) {
                    _ = try rcv.recordBatches.items[@bitCast(u32, j)].Pack(__builder, __pack_opts);
                }
                recordBatches_off = try __builder.endVector(@bitCast(u32, recordBatches_len));
            }
        }

        var custom_metadata_off: u32 = 0;
        if (rcv.custom_metadata.items.len != 0) {
            const custom_metadata_len = @intCast(i32, rcv.custom_metadata.items.len);
            try __tmp_offsets.ensureTotalCapacity(__pack_opts.allocator.?, @bitCast(u32, custom_metadata_len));
            __tmp_offsets.items.len = @bitCast(u32, custom_metadata_len);
            for (__tmp_offsets.items, 0..) |*off, j| {
                off.* = try KeyValueT.Pack(rcv.custom_metadata.items[j], __builder, __pack_opts);
            }
            _ = try Footer.StartCustomMetadataVector(__builder, custom_metadata_len);
            {
                var j = custom_metadata_len - 1;
                while (j >= 0) : (j -= 1) {
                    try __builder.prependUOff(__tmp_offsets.items[@bitCast(u32, j)]);
                }
                custom_metadata_off = try __builder.endVector(@bitCast(u32, custom_metadata_len));
            }
        }

        try Footer.Start(__builder);
        try Footer.AddVersion(__builder, rcv.version);
        try Footer.AddSchema_(__builder, schema_off);
        try Footer.AddDictionaries(__builder, dictionaries_off);
        try Footer.AddRecordBatches(__builder, recordBatches_off);
        try Footer.AddCustomMetadata(__builder, custom_metadata_off);
        return Footer.End(__builder);
    }

    pub fn UnpackTo(rcv: Footer, t: *FooterT, __pack_opts: fb.common.PackOptions) !void {
        _ = .{__pack_opts};
        t.version = rcv.Version();

        if (rcv.Schema_()) |x| {
            if (t.schema == null) {
                t.schema = try __pack_opts.allocator.?.create(SchemaT);
                t.schema.?.* = .{};
            }
            try SchemaT.UnpackTo(x, t.schema.?, __pack_opts);
        }

        const dictionaries_len = rcv.DictionariesLen();
        t.dictionaries = try std.ArrayListUnmanaged(BlockT).initCapacity(__pack_opts.allocator.?, @bitCast(u32, dictionaries_len));
        t.dictionaries.expandToCapacity();
        {
            var j: u32 = 0;
            while (j < dictionaries_len) : (j += 1) {
                const x = rcv.Dictionaries(j).?;
                t.dictionaries.items[j] = try x.Unpack(__pack_opts);
            }
        }

        const recordBatches_len = rcv.RecordBatchesLen();
        t.recordBatches = try std.ArrayListUnmanaged(BlockT).initCapacity(__pack_opts.allocator.?, @bitCast(u32, recordBatches_len));
        t.recordBatches.expandToCapacity();
        {
            var j: u32 = 0;
            while (j < recordBatches_len) : (j += 1) {
                const x = rcv.RecordBatches(j).?;
                t.recordBatches.items[j] = try x.Unpack(__pack_opts);
            }
        }

        const custom_metadata_len = rcv.CustomMetadataLen();
        t.custom_metadata = try std.ArrayListUnmanaged(KeyValueT).initCapacity(__pack_opts.allocator.?, @bitCast(u32, custom_metadata_len));
        t.custom_metadata.expandToCapacity();
        {
            var j: u32 = 0;
            while (j < custom_metadata_len) : (j += 1) {
                const x = rcv.CustomMetadata(j).?;
                t.custom_metadata.items[j] = try x.Unpack(__pack_opts);
            }
        }
    }

    pub fn Unpack(rcv: Footer, __pack_opts: fb.common.PackOptions) fb.common.PackError!FooterT {
        var t = FooterT{};
        try FooterT.UnpackTo(rcv, &t, __pack_opts);
        return t;
    }

    pub fn deinit(self: *FooterT, allocator: std.mem.Allocator) void {
        _ = .{ self, allocator };
        if (self.schema) |x| {
            x.deinit(allocator);
            allocator.destroy(x);
        }
        for (self.dictionaries.items) |*it| it.deinit(allocator);
        self.dictionaries.deinit(allocator);
        for (self.recordBatches.items) |*it| it.deinit(allocator);
        self.recordBatches.deinit(allocator);
        for (self.custom_metadata.items) |*it| it.deinit(allocator);
        self.custom_metadata.deinit(allocator);
    }
};

pub const Footer = struct {
    _tab: fb.Table,

    pub fn GetRootAs(buf: []u8, offset: u32) Footer {
        const n = fb.encode.read(u32, buf[offset..]);
        return Footer.init(buf, n + offset);
    }

    pub fn GetSizePrefixedRootAs(buf: []u8, offset: u32) Footer {
        const n = fb.encode.read(u32, buf[offset + fb.Builder.size_u32 ..]);
        return Footer.init(buf, n + offset + fb.Builder.size_u32);
    }

    pub fn init(bytes: []u8, pos: u32) Footer {
        return .{ ._tab = .{ .bytes = bytes, .pos = pos } };
    }

    pub fn Table(x: Footer) fb.Table {
        return x._tab;
    }

    pub fn Version(rcv: Footer) MetadataVersion {
        const o = rcv._tab.offset(4);
        if (o != 0) {
            return rcv._tab.read(MetadataVersion, o + rcv._tab.pos);
        }
        return @intToEnum(MetadataVersion, 0);
    }

    pub fn MutateVersion(rcv: Footer, n: MetadataVersion) bool {
        return rcv._tab.mutateSlot(MetadataVersion, 4, n);
    }

    pub fn Schema_(rcv: Footer) ?Schema {
        const o = rcv._tab.offset(6);
        if (o != 0) {
            const x = rcv._tab.indirect(o + rcv._tab.pos);
            return Schema.init(rcv._tab.bytes, x);
        }
        return null;
    }

    pub fn Dictionaries(rcv: Footer, j: usize) ?Block {
        const o = rcv._tab.offset(8);
        if (o != 0) {
            var x = rcv._tab.vector(o);
            x += @intCast(u32, j) * 24;
            return Block.init(rcv._tab.bytes, x);
        }
        return null;
    }

    pub fn DictionariesLen(rcv: Footer) u32 {
        const o = rcv._tab.offset(8);
        if (o != 0) {
            return rcv._tab.vectorLen(o);
        }
        return 0;
    }

    pub fn RecordBatches(rcv: Footer, j: usize) ?Block {
        const o = rcv._tab.offset(10);
        if (o != 0) {
            var x = rcv._tab.vector(o);
            x += @intCast(u32, j) * 24;
            return Block.init(rcv._tab.bytes, x);
        }
        return null;
    }

    pub fn RecordBatchesLen(rcv: Footer) u32 {
        const o = rcv._tab.offset(10);
        if (o != 0) {
            return rcv._tab.vectorLen(o);
        }
        return 0;
    }

    /// User-defined metadata
    pub fn CustomMetadata(rcv: Footer, j: usize) ?KeyValue {
        const o = rcv._tab.offset(12);
        if (o != 0) {
            var x = rcv._tab.vector(o);
            x += @intCast(u32, j) * 4;
            x = rcv._tab.indirect(x);
            return KeyValue.init(rcv._tab.bytes, x);
        }
        return null;
    }

    pub fn CustomMetadataLen(rcv: Footer) u32 {
        const o = rcv._tab.offset(12);
        if (o != 0) {
            return rcv._tab.vectorLen(o);
        }
        return 0;
    }

    pub fn Start(__builder: *Builder) !void {
        try __builder.startObject(5);
    }
    pub fn AddVersion(__builder: *Builder, version: MetadataVersion) !void {
        try __builder.prependSlot(MetadataVersion, 0, version, @intToEnum(MetadataVersion, 0));
    }

    pub fn AddSchema_(__builder: *Builder, schema: u32) !void {
        try __builder.prependSlotUOff(1, schema, 0);
    }

    pub fn AddDictionaries(__builder: *Builder, dictionaries: u32) !void {
        try __builder.prependSlotUOff(2, dictionaries, 0);
    }

    pub fn StartDictionariesVector(__builder: *Builder, num_elems: i32) !u32 {
        return __builder.startVector(24, num_elems, 8);
    }
    pub fn AddRecordBatches(__builder: *Builder, recordBatches: u32) !void {
        try __builder.prependSlotUOff(3, recordBatches, 0);
    }

    pub fn StartRecordBatchesVector(__builder: *Builder, num_elems: i32) !u32 {
        return __builder.startVector(24, num_elems, 8);
    }
    pub fn AddCustomMetadata(__builder: *Builder, custom_metadata: u32) !void {
        try __builder.prependSlotUOff(4, custom_metadata, 0);
    }

    pub fn StartCustomMetadataVector(__builder: *Builder, num_elems: i32) !u32 {
        return __builder.startVector(4, num_elems, 1);
    }
    pub fn End(__builder: *Builder) !u32 {
        return __builder.endObject();
    }

    pub fn Unpack(rcv: Footer, __pack_opts: fb.common.PackOptions) !FooterT {
        return FooterT.Unpack(rcv, __pack_opts);
    }
    pub fn BufferHasIdentifier(buf: []const u8, off: u32) bool {
        return fb.BufferHasIdentifier(buf, off, __file_ident, false);
    }

    pub fn SizePrefixedBufferHasIdentifier(buf: []const u8, off: u32) bool {
        return fb.BufferHasIdentifier(buf, off, __file_ident, true);
    }
    pub fn FinishBuffer(__builder: *Builder, root: u32) !void {
        return __builder.finishWithFileIdentifier(root, __file_ident);
    }

    pub fn FinishSizePrefixedBuffer(__builder: *Builder, root: u32) !void {
        return __builder.finishSizePrefixedWithFileIdentifier(root, __file_ident);
    }
};
