//!
//! generated by flatc-zig
//! binary:     src/ipc/gen/format/Schema.bfbs
//! schema:     format/Schema.fbs
//! file ident: //Schema.fbs
//! typename    Map
//!

const std = @import("std");
const fb = @import("flatbufferz");
const Builder = fb.Builder;

/// A Map is a logical nested type that is represented as
///
/// List<entries: Struct<key: K, value: V>>
///
/// In this layout, the keys and values are each respectively contiguous. We do
/// not constrain the key and value types, so the application is responsible
/// for ensuring that the keys are hashable and unique. Whether the keys are sorted
/// may be set in the metadata for this field.
///
/// In a field with Map type, the field has a child Struct field, which then
/// has two children: key type and the second the value type. The names of the
/// child fields may be respectively "entries", "key", and "value", but this is
/// not enforced.
///
/// Map
/// ```text
///   - child[0] entries: Struct
///     - child[0] key: K
///     - child[1] value: V
/// ```
/// Neither the "entries" field nor the "key" field may be nullable.
///
/// The metadata is structured so that Arrow systems without special handling
/// for Map can make Map an alias for List. The "layout" attribute for the Map
/// field must have the same contents as a List.
pub const MapT = struct {
    /// Set to true if the keys within each value are sorted
    keysSorted: bool = false,

    pub fn Pack(rcv: MapT, __builder: *Builder, __pack_opts: fb.common.PackOptions) fb.common.PackError!u32 {
        _ = .{__pack_opts};
        var __tmp_offsets = std.ArrayListUnmanaged(u32){};
        defer if (__pack_opts.allocator) |alloc| __tmp_offsets.deinit(alloc);
        try Map.Start(__builder);
        try Map.AddKeysSorted(__builder, rcv.keysSorted);
        return Map.End(__builder);
    }

    pub fn UnpackTo(rcv: Map, t: *MapT, __pack_opts: fb.common.PackOptions) !void {
        _ = .{__pack_opts};
        t.keysSorted = rcv.KeysSorted();
    }

    pub fn Unpack(rcv: Map, __pack_opts: fb.common.PackOptions) fb.common.PackError!MapT {
        var t = MapT{};
        try MapT.UnpackTo(rcv, &t, __pack_opts);
        return t;
    }

    pub fn deinit(self: *MapT, allocator: std.mem.Allocator) void {
        _ = .{ self, allocator };
    }
};

pub const Map = struct {
    _tab: fb.Table,

    pub fn GetRootAs(buf: []u8, offset: u32) Map {
        const n = fb.encode.read(u32, buf[offset..]);
        return Map.init(buf, n + offset);
    }

    pub fn GetSizePrefixedRootAs(buf: []u8, offset: u32) Map {
        const n = fb.encode.read(u32, buf[offset + fb.Builder.size_u32 ..]);
        return Map.init(buf, n + offset + fb.Builder.size_u32);
    }

    pub fn init(bytes: []u8, pos: u32) Map {
        return .{ ._tab = .{ .bytes = bytes, .pos = pos } };
    }

    pub fn Table(x: Map) fb.Table {
        return x._tab;
    }

    /// Set to true if the keys within each value are sorted
    pub fn KeysSorted(rcv: Map) bool {
        const o = rcv._tab.offset(4);
        if (o != 0) {
            return rcv._tab.read(bool, o + rcv._tab.pos);
        }
        return false;
    }

    pub fn MutateKeysSorted(rcv: Map, n: bool) bool {
        return rcv._tab.mutateSlot(bool, 4, n);
    }

    pub fn Start(__builder: *Builder) !void {
        try __builder.startObject(1);
    }
    pub fn AddKeysSorted(__builder: *Builder, keysSorted: bool) !void {
        try __builder.prependSlot(bool, 0, keysSorted, false);
    }

    pub fn End(__builder: *Builder) !u32 {
        return __builder.endObject();
    }

    pub fn Unpack(rcv: Map, __pack_opts: fb.common.PackOptions) !MapT {
        return MapT.Unpack(rcv, __pack_opts);
    }
    pub fn FinishBuffer(__builder: *Builder, root: u32) !void {
        return __builder.Finish(root);
    }

    pub fn FinishSizePrefixedBuffer(__builder: *Builder, root: u32) !void {
        return __builder.FinishSizePrefixed(root);
    }
};
