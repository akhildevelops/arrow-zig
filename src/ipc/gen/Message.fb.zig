//!
//! generated by flatc-zig
//! binary:     src/ipc/gen/format/Message.bfbs
//! schema:     format/Message.fbs
//! file ident: //Message.fbs
//! typename    Message
//!

const std = @import("std");
const fb = @import("flatbufferz");
const Builder = fb.Builder;

const KeyValue = @import("KeyValue.fb.zig").KeyValue;
const KeyValueT = @import("KeyValue.fb.zig").KeyValueT;
const MessageHeader = @import("MessageHeader.fb.zig").MessageHeader;
const MessageHeaderT = @import("MessageHeader.fb.zig").MessageHeaderT;
const MetadataVersion = @import("MetadataVersion.fb.zig").MetadataVersion;

pub const __file_ident: fb.Builder.Fid = "".*;
pub const __file_ext = "";

pub const MessageT = struct {
    version: MetadataVersion = @intToEnum(MetadataVersion, 0),
    header: MessageHeaderT = @intToEnum(MessageHeader.Tag, 0),
    bodyLength: i64 = 0,
    custom_metadata: std.ArrayListUnmanaged(KeyValueT) = .{},

    pub fn Pack(rcv: MessageT, __builder: *Builder, __pack_opts: fb.common.PackOptions) fb.common.PackError!u32 {
        _ = .{__pack_opts};
        var __tmp_offsets = std.ArrayListUnmanaged(u32){};
        defer if (__pack_opts.allocator) |alloc| __tmp_offsets.deinit(alloc);
        const header_off = try rcv.header.Pack(__builder, __pack_opts);

        var custom_metadata_off: u32 = 0;
        if (rcv.custom_metadata.items.len != 0) {
            const custom_metadata_len = @intCast(i32, rcv.custom_metadata.items.len);
            try __tmp_offsets.ensureTotalCapacity(__pack_opts.allocator.?, @bitCast(u32, custom_metadata_len));
            __tmp_offsets.items.len = @bitCast(u32, custom_metadata_len);
            for (__tmp_offsets.items, 0..) |*off, j| {
                off.* = try KeyValueT.Pack(rcv.custom_metadata.items[j], __builder, __pack_opts);
            }
            _ = try Message.StartCustomMetadataVector(__builder, custom_metadata_len);
            {
                var j = custom_metadata_len - 1;
                while (j >= 0) : (j -= 1) {
                    try __builder.prependUOff(__tmp_offsets.items[@bitCast(u32, j)]);
                }
                custom_metadata_off = try __builder.endVector(@bitCast(u32, custom_metadata_len));
            }
        }

        try Message.Start(__builder);
        try Message.AddVersion(__builder, rcv.version);
        try Message.AddHeaderType(__builder, rcv.header);
        try Message.AddHeader(__builder, header_off);
        try Message.AddBodyLength(__builder, rcv.bodyLength);
        try Message.AddCustomMetadata(__builder, custom_metadata_off);
        return Message.End(__builder);
    }

    pub fn UnpackTo(rcv: Message, t: *MessageT, __pack_opts: fb.common.PackOptions) !void {
        _ = .{__pack_opts};
        t.version = rcv.Version();

        if (rcv.Header()) |_tab| {
            t.header = try MessageHeaderT.Unpack(rcv.HeaderType(), _tab, __pack_opts);
        }

        t.bodyLength = rcv.BodyLength();

        const custom_metadata_len = rcv.CustomMetadataLen();
        t.custom_metadata = try std.ArrayListUnmanaged(KeyValueT).initCapacity(__pack_opts.allocator.?, @bitCast(u32, custom_metadata_len));
        t.custom_metadata.expandToCapacity();
        {
            var j: u32 = 0;
            while (j < custom_metadata_len) : (j += 1) {
                const x = rcv.CustomMetadata(j).?;
                t.custom_metadata.items[j] = try x.Unpack(__pack_opts);
            }
        }
    }

    pub fn Unpack(rcv: Message, __pack_opts: fb.common.PackOptions) fb.common.PackError!MessageT {
        var t = MessageT{};
        try MessageT.UnpackTo(rcv, &t, __pack_opts);
        return t;
    }

    pub fn deinit(self: *MessageT, allocator: std.mem.Allocator) void {
        _ = .{ self, allocator };
        self.header.deinit(allocator);
        for (self.custom_metadata.items) |*it| it.deinit(allocator);
        self.custom_metadata.deinit(allocator);
    }
};

pub const Message = struct {
    _tab: fb.Table,

    pub fn GetRootAs(buf: []u8, offset: u32) Message {
        const n = fb.encode.read(u32, buf[offset..]);
        return Message.init(buf, n + offset);
    }

    pub fn GetSizePrefixedRootAs(buf: []u8, offset: u32) Message {
        const n = fb.encode.read(u32, buf[offset + fb.Builder.size_u32 ..]);
        return Message.init(buf, n + offset + fb.Builder.size_u32);
    }

    pub fn init(bytes: []u8, pos: u32) Message {
        return .{ ._tab = .{ .bytes = bytes, .pos = pos } };
    }

    pub fn Table(x: Message) fb.Table {
        return x._tab;
    }

    pub fn Version(rcv: Message) MetadataVersion {
        const o = rcv._tab.offset(4);
        if (o != 0) {
            return rcv._tab.read(MetadataVersion, o + rcv._tab.pos);
        }
        return @intToEnum(MetadataVersion, 0);
    }

    pub fn MutateVersion(rcv: Message, n: MetadataVersion) bool {
        return rcv._tab.mutateSlot(MetadataVersion, 4, n);
    }

    pub fn HeaderType(rcv: Message) MessageHeader.Tag {
        const o = rcv._tab.offset(6);
        if (o != 0) {
            return rcv._tab.read(MessageHeader.Tag, o + rcv._tab.pos);
        }
        return @intToEnum(MessageHeader.Tag, 0);
    }

    pub fn MutateHeaderType(rcv: Message, n: MessageHeader) bool {
        return rcv._tab.mutateSlot(MessageHeader, 6, n);
    }

    pub fn Header(rcv: Message) ?fb.Table {
        const o = rcv._tab.offset(8);
        if (o != 0) {
            return rcv._tab.union_(o);
        }
        return null;
    }

    pub fn BodyLength(rcv: Message) i64 {
        const o = rcv._tab.offset(10);
        if (o != 0) {
            return rcv._tab.read(i64, o + rcv._tab.pos);
        }
        return 0;
    }

    pub fn MutateBodyLength(rcv: Message, n: i64) bool {
        return rcv._tab.mutateSlot(i64, 10, n);
    }

    pub fn CustomMetadata(rcv: Message, j: usize) ?KeyValue {
        const o = rcv._tab.offset(12);
        if (o != 0) {
            var x = rcv._tab.vector(o);
            x += @intCast(u32, j) * 4;
            x = rcv._tab.indirect(x);
            return KeyValue.init(rcv._tab.bytes, x);
        }
        return null;
    }

    pub fn CustomMetadataLen(rcv: Message) u32 {
        const o = rcv._tab.offset(12);
        if (o != 0) {
            return rcv._tab.vectorLen(o);
        }
        return 0;
    }

    pub fn Start(__builder: *Builder) !void {
        try __builder.startObject(5);
    }
    pub fn AddVersion(__builder: *Builder, version: MetadataVersion) !void {
        try __builder.prependSlot(MetadataVersion, 0, version, @intToEnum(MetadataVersion, 0));
    }

    pub fn AddHeaderType(__builder: *Builder, header_type: MessageHeader.Tag) !void {
        try __builder.prependSlot(MessageHeader.Tag, 1, header_type, @intToEnum(MessageHeader.Tag, 0));
    }

    pub fn AddHeader(__builder: *Builder, header: u32) !void {
        try __builder.prependSlotUOff(2, header, 0);
    }

    pub fn AddBodyLength(__builder: *Builder, bodyLength: i64) !void {
        try __builder.prependSlot(i64, 3, bodyLength, 0);
    }

    pub fn AddCustomMetadata(__builder: *Builder, custom_metadata: u32) !void {
        try __builder.prependSlotUOff(4, custom_metadata, 0);
    }

    pub fn StartCustomMetadataVector(__builder: *Builder, num_elems: i32) !u32 {
        return __builder.startVector(4, num_elems, 1);
    }
    pub fn End(__builder: *Builder) !u32 {
        return __builder.endObject();
    }

    pub fn Unpack(rcv: Message, __pack_opts: fb.common.PackOptions) !MessageT {
        return MessageT.Unpack(rcv, __pack_opts);
    }
    pub fn BufferHasIdentifier(buf: []const u8, off: u32) bool {
        return fb.BufferHasIdentifier(buf, off, __file_ident, false);
    }

    pub fn SizePrefixedBufferHasIdentifier(buf: []const u8, off: u32) bool {
        return fb.BufferHasIdentifier(buf, off, __file_ident, true);
    }
    pub fn FinishBuffer(__builder: *Builder, root: u32) !void {
        return __builder.finishWithFileIdentifier(root, __file_ident);
    }

    pub fn FinishSizePrefixedBuffer(__builder: *Builder, root: u32) !void {
        return __builder.finishSizePrefixedWithFileIdentifier(root, __file_ident);
    }
};
