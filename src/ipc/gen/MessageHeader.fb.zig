//!
//! generated by flatc-zig
//! binary:     gen/format/Message.bfbs
//! schema:     format/Message.fbs
//! file ident: //Message.fbs
//! typename    MessageHeader
//!

const std = @import("std");
const fb = @import("flatbufferz");
const Builder = fb.Builder;

const Schema = @import("Schema.fb.zig").Schema;
const SchemaT = @import("Schema.fb.zig").SchemaT;
const RecordBatch = @import("RecordBatch.fb.zig").RecordBatch;
const RecordBatchT = @import("RecordBatch.fb.zig").RecordBatchT;
const DictionaryBatch = @import("DictionaryBatch.fb.zig").DictionaryBatch;
const DictionaryBatchT = @import("DictionaryBatch.fb.zig").DictionaryBatchT;

/// ----------------------------------------------------------------------
/// The root Message type
/// This union enables us to easily send different message types without
/// redundant storage, and in the future we can easily add new message types.
///
/// Arrow implementations do not need to implement all of the message types,
/// which may include experimental metadata types. For maximum compatibility,
/// it is best to send data using RecordBatch
pub const MessageHeader = union(enum) {
    NONE,
    Schema: Schema,
    DictionaryBatch: DictionaryBatch,
    RecordBatch: RecordBatch,

    pub const Tag = std.meta.Tag(@This());
    pub fn tagName(v: @This()) []const u8 {
        return @tagName(v);
    }
};

pub const MessageHeaderT = union(MessageHeader.Tag) {
    NONE: void,
    Schema: ?*SchemaT,
    DictionaryBatch: ?*DictionaryBatchT,
    RecordBatch: ?*RecordBatchT,

    pub fn deinit(self: *MessageHeaderT, allocator: std.mem.Allocator) void {
        switch (self.*) {
            .NONE => {},
            .Schema => |mptr| if (mptr) |x| {
                x.deinit(allocator);
                allocator.destroy(x);
                self.Schema = null;
            },
            .DictionaryBatch => |mptr| if (mptr) |x| {
                x.deinit(allocator);
                allocator.destroy(x);
                self.DictionaryBatch = null;
            },
            .RecordBatch => |mptr| if (mptr) |x| {
                x.deinit(allocator);
                allocator.destroy(x);
                self.RecordBatch = null;
            },
        }
    }

    pub fn Pack(rcv: MessageHeaderT, __builder: *Builder, __pack_opts: fb.common.PackOptions) !u32 {
        // std.debug.print("pack() MessageHeaderT rcv=.{s}\n", .{@tagName(rcv)});
        switch (rcv) {
            .NONE => {},
            .Schema => |x| return x.?.Pack(__builder, __pack_opts),
            .DictionaryBatch => |x| return x.?.Pack(__builder, __pack_opts),
            .RecordBatch => |x| return x.?.Pack(__builder, __pack_opts),
        }
        return 0;
    }

    pub fn Unpack(rcv: MessageHeader.Tag, table: fb.Table, __pack_opts: fb.common.PackOptions) !MessageHeaderT {
        // std.debug.print("unpack() MessageHeader rcv=.{s}\n", .{@tagName(rcv)});
        _ = .{__pack_opts};
        switch (rcv) {
            .NONE => return .NONE,
            .Schema => {
                var x = Schema.init(table.bytes, table.pos);
                var ptr = try __pack_opts.allocator.?.create(SchemaT);
                ptr.* = try SchemaT.Unpack(x, __pack_opts);
                return .{ .Schema = ptr };
            },
            .DictionaryBatch => {
                var x = DictionaryBatch.init(table.bytes, table.pos);
                var ptr = try __pack_opts.allocator.?.create(DictionaryBatchT);
                ptr.* = try DictionaryBatchT.Unpack(x, __pack_opts);
                return .{ .DictionaryBatch = ptr };
            },
            .RecordBatch => {
                var x = RecordBatch.init(table.bytes, table.pos);
                var ptr = try __pack_opts.allocator.?.create(RecordBatchT);
                ptr.* = try RecordBatchT.Unpack(x, __pack_opts);
                return .{ .RecordBatch = ptr };
            },
        }
        unreachable;
    }
};
