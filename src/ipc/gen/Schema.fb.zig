//!
//! generated by flatc-zig
//! binary:     gen/format/Schema.bfbs
//! schema:     format/Schema.fbs
//! file ident: //Schema.fbs
//! typename    Schema
//!

const std = @import("std");
const fb = @import("flatbufferz");
const Builder = fb.Builder;

const Endianness = @import("Endianness.fb.zig").Endianness;
const Field = @import("Field.fb.zig").Field;
const FieldT = @import("Field.fb.zig").FieldT;
const KeyValue = @import("KeyValue.fb.zig").KeyValue;
const KeyValueT = @import("KeyValue.fb.zig").KeyValueT;

pub const __file_ident: fb.Builder.Fid = "".*;
pub const __file_ext = "";

/// ----------------------------------------------------------------------
/// A Schema describes the columns in a row batch
pub const SchemaT = struct {
    /// endianness of the buffer
    /// it is Little Endian by default
    /// if endianness doesn't match the underlying system then the vectors need to be converted
    endianness: Endianness = @intToEnum(Endianness, 0),
    fields: std.ArrayListUnmanaged(FieldT) = .{},
    custom_metadata: std.ArrayListUnmanaged(KeyValueT) = .{},
    /// Features used in the stream/file.
    features: std.ArrayListUnmanaged(i64) = .{},

    pub fn Pack(rcv: SchemaT, __builder: *Builder, __pack_opts: fb.common.PackOptions) fb.common.PackError!u32 {
        _ = .{__pack_opts};
        var __tmp_offsets = std.ArrayListUnmanaged(u32){};
        defer if (__pack_opts.allocator) |alloc| __tmp_offsets.deinit(alloc);
        var fields_off: u32 = 0;
        if (rcv.fields.items.len != 0) {
            const fields_len = @intCast(i32, rcv.fields.items.len);
            try __tmp_offsets.ensureTotalCapacity(__pack_opts.allocator.?, @bitCast(u32, fields_len));
            __tmp_offsets.items.len = @bitCast(u32, fields_len);
            for (__tmp_offsets.items, 0..) |*off, j| {
                off.* = try FieldT.Pack(rcv.fields.items[j], __builder, __pack_opts);
            }
            _ = try Schema.StartFieldsVector(__builder, fields_len);
            {
                var j = fields_len - 1;
                while (j >= 0) : (j -= 1) {
                    try __builder.prependUOff(__tmp_offsets.items[@bitCast(u32, j)]);
                }
                fields_off = try __builder.endVector(@bitCast(u32, fields_len));
            }
        }

        var custom_metadata_off: u32 = 0;
        if (rcv.custom_metadata.items.len != 0) {
            const custom_metadata_len = @intCast(i32, rcv.custom_metadata.items.len);
            try __tmp_offsets.ensureTotalCapacity(__pack_opts.allocator.?, @bitCast(u32, custom_metadata_len));
            __tmp_offsets.items.len = @bitCast(u32, custom_metadata_len);
            for (__tmp_offsets.items, 0..) |*off, j| {
                off.* = try KeyValueT.Pack(rcv.custom_metadata.items[j], __builder, __pack_opts);
            }
            _ = try Schema.StartCustomMetadataVector(__builder, custom_metadata_len);
            {
                var j = custom_metadata_len - 1;
                while (j >= 0) : (j -= 1) {
                    try __builder.prependUOff(__tmp_offsets.items[@bitCast(u32, j)]);
                }
                custom_metadata_off = try __builder.endVector(@bitCast(u32, custom_metadata_len));
            }
        }

        var features_off: u32 = 0;
        if (rcv.features.items.len != 0) {
            const features_len = @intCast(i32, rcv.features.items.len);
            _ = try Schema.StartFeaturesVector(__builder, features_len);
            {
                var j = features_len - 1;
                while (j >= 0) : (j -= 1) {
                    try __builder.prepend(i64, rcv.features.items[@bitCast(u32, j)]);
                }
                features_off = try __builder.endVector(@bitCast(u32, features_len));
            }
        }

        try Schema.Start(__builder);
        try Schema.AddEndianness_(__builder, rcv.endianness);
        try Schema.AddFields(__builder, fields_off);
        try Schema.AddCustomMetadata(__builder, custom_metadata_off);
        try Schema.AddFeatures(__builder, features_off);
        return Schema.End(__builder);
    }

    pub fn UnpackTo(rcv: Schema, t: *SchemaT, __pack_opts: fb.common.PackOptions) !void {
        _ = .{__pack_opts};
        t.endianness = rcv.Endianness_();

        const fields_len = rcv.FieldsLen();
        t.fields = try std.ArrayListUnmanaged(FieldT).initCapacity(__pack_opts.allocator.?, @bitCast(u32, fields_len));
        t.fields.expandToCapacity();
        {
            var j: u32 = 0;
            while (j < fields_len) : (j += 1) {
                const x = rcv.Fields(j).?;
                t.fields.items[j] = try x.Unpack(__pack_opts);
            }
        }

        const custom_metadata_len = rcv.CustomMetadataLen();
        t.custom_metadata = try std.ArrayListUnmanaged(KeyValueT).initCapacity(__pack_opts.allocator.?, @bitCast(u32, custom_metadata_len));
        t.custom_metadata.expandToCapacity();
        {
            var j: u32 = 0;
            while (j < custom_metadata_len) : (j += 1) {
                const x = rcv.CustomMetadata(j).?;
                t.custom_metadata.items[j] = try x.Unpack(__pack_opts);
            }
        }

        const features_len = rcv.FeaturesLen();
        t.features = try std.ArrayListUnmanaged(i64).initCapacity(__pack_opts.allocator.?, @bitCast(u32, features_len));
        t.features.expandToCapacity();
        {
            var j: u32 = 0;
            while (j < features_len) : (j += 1) {
                t.features.items[j] = rcv.Features(j).?;
            }
        }
    }

    pub fn Unpack(rcv: Schema, __pack_opts: fb.common.PackOptions) fb.common.PackError!SchemaT {
        var t = SchemaT{};
        try SchemaT.UnpackTo(rcv, &t, __pack_opts);
        return t;
    }

    pub fn deinit(self: *SchemaT, allocator: std.mem.Allocator) void {
        _ = .{ self, allocator };
        for (self.fields.items) |*it| it.deinit(allocator);
        self.fields.deinit(allocator);
        for (self.custom_metadata.items) |*it| it.deinit(allocator);
        self.custom_metadata.deinit(allocator);
        self.features.deinit(allocator);
    }
};

pub const Schema = struct {
    _tab: fb.Table,

    pub fn GetRootAs(buf: []u8, offset: u32) Schema {
        const n = fb.encode.read(u32, buf[offset..]);
        return Schema.init(buf, n + offset);
    }

    pub fn GetSizePrefixedRootAs(buf: []u8, offset: u32) Schema {
        const n = fb.encode.read(u32, buf[offset + fb.Builder.size_u32 ..]);
        return Schema.init(buf, n + offset + fb.Builder.size_u32);
    }

    pub fn init(bytes: []u8, pos: u32) Schema {
        return .{ ._tab = .{ .bytes = bytes, .pos = pos } };
    }

    pub fn Table(x: Schema) fb.Table {
        return x._tab;
    }

    /// endianness of the buffer
    /// it is Little Endian by default
    /// if endianness doesn't match the underlying system then the vectors need to be converted
    pub fn Endianness_(rcv: Schema) Endianness {
        const o = rcv._tab.offset(4);
        if (o != 0) {
            return rcv._tab.read(Endianness, o + rcv._tab.pos);
        }
        return @intToEnum(Endianness, 0);
    }

    pub fn MutateEndianness_(rcv: Schema, n: Endianness) bool {
        return rcv._tab.mutateSlot(Endianness, 4, n);
    }

    pub fn Fields(rcv: Schema, j: usize) ?Field {
        const o = rcv._tab.offset(6);
        if (o != 0) {
            var x = rcv._tab.vector(o);
            x += @intCast(u32, j) * 4;
            x = rcv._tab.indirect(x);
            return Field.init(rcv._tab.bytes, x);
        }
        return null;
    }

    pub fn FieldsLen(rcv: Schema) u32 {
        const o = rcv._tab.offset(6);
        if (o != 0) {
            return rcv._tab.vectorLen(o);
        }
        return 0;
    }

    pub fn CustomMetadata(rcv: Schema, j: usize) ?KeyValue {
        const o = rcv._tab.offset(8);
        if (o != 0) {
            var x = rcv._tab.vector(o);
            x += @intCast(u32, j) * 4;
            x = rcv._tab.indirect(x);
            return KeyValue.init(rcv._tab.bytes, x);
        }
        return null;
    }

    pub fn CustomMetadataLen(rcv: Schema) u32 {
        const o = rcv._tab.offset(8);
        if (o != 0) {
            return rcv._tab.vectorLen(o);
        }
        return 0;
    }

    /// Features used in the stream/file.
    pub fn Features(rcv: Schema, j: usize) ?i64 {
        const o = rcv._tab.offset(10);
        if (o != 0) {
            const a = rcv._tab.vector(o);
            return rcv._tab.read(i64, a + @intCast(u32, j) * 8);
        }
        return 0;
    }

    pub fn FeaturesLen(rcv: Schema) u32 {
        const o = rcv._tab.offset(10);
        if (o != 0) {
            return rcv._tab.vectorLen(o);
        }
        return 0;
    }

    pub fn MutateFeatures(rcv: Schema, j: usize, n: i64) bool {
        const o = rcv._tab.offset(10);
        if (o != 0) {
            const a = rcv._tab.vector(o);
            return rcv._tab.mutate(i64, a + @intCast(u32, j) * 8, n);
        }
        return false;
    }

    pub fn Start(__builder: *Builder) !void {
        try __builder.startObject(4);
    }
    pub fn AddEndianness_(__builder: *Builder, endianness: Endianness) !void {
        try __builder.prependSlot(Endianness, 0, endianness, @intToEnum(Endianness, 0));
    }

    pub fn AddFields(__builder: *Builder, fields: u32) !void {
        try __builder.prependSlotUOff(1, fields, 0);
    }

    pub fn StartFieldsVector(__builder: *Builder, num_elems: i32) !u32 {
        return __builder.startVector(4, num_elems, 1);
    }
    pub fn AddCustomMetadata(__builder: *Builder, custom_metadata: u32) !void {
        try __builder.prependSlotUOff(2, custom_metadata, 0);
    }

    pub fn StartCustomMetadataVector(__builder: *Builder, num_elems: i32) !u32 {
        return __builder.startVector(4, num_elems, 1);
    }
    pub fn AddFeatures(__builder: *Builder, features: u32) !void {
        try __builder.prependSlotUOff(3, features, 0);
    }

    pub fn StartFeaturesVector(__builder: *Builder, num_elems: i32) !u32 {
        return __builder.startVector(8, num_elems, 8);
    }
    pub fn End(__builder: *Builder) !u32 {
        return __builder.endObject();
    }

    pub fn Unpack(rcv: Schema, __pack_opts: fb.common.PackOptions) !SchemaT {
        return SchemaT.Unpack(rcv, __pack_opts);
    }
    pub fn BufferHasIdentifier(buf: []const u8, off: u32) bool {
        return fb.BufferHasIdentifier(buf, off, __file_ident, false);
    }

    pub fn SizePrefixedBufferHasIdentifier(buf: []const u8, off: u32) bool {
        return fb.BufferHasIdentifier(buf, off, __file_ident, true);
    }
    pub fn FinishBuffer(__builder: *Builder, root: u32) !void {
        return __builder.finishWithFileIdentifier(root, __file_ident);
    }

    pub fn FinishSizePrefixedBuffer(__builder: *Builder, root: u32) !void {
        return __builder.finishSizePrefixedWithFileIdentifier(root, __file_ident);
    }
};
