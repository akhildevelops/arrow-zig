//! generated by flatc-zig from Schema.fbs
// `nFields`, `nBuffers`, `print`, and `initFromArray`, and tests added manually

const flatbuffers = @import("flatbuffers");
const std = @import("std");
const types = @import("lib.zig");
const IpcError = @import("../shared.zig").IpcError;
const Array = @import("../../array/array.zig").Array;
const arrays = @import("../../sample_arrays.zig");

/// ----------------------------------------------------------------------
/// A Schema describes the columns in a row batch
pub const Schema = struct {
    /// endianness of the buffer
    /// it is Little Endian by default
    /// if endianness doesn't match the underlying system then the vectors need to be converted
    endianness: types.Endianness = .little,
    fields: []types.Field,
    custom_metadata: []types.KeyValue,
    /// Features used in the stream/file.
    features: []types.Feature,

    const Self = @This();

    pub fn init(allocator: std.mem.Allocator, packed_: PackedSchema) flatbuffers.Error!Self {
        const fields_ = try flatbuffers.unpackVector(allocator, types.Field, packed_, "fields");
        errdefer {
            for (fields_) |f| f.deinit(allocator);
            allocator.free(fields_);
        }
        const custom_metadata_ = try flatbuffers.unpackVector(allocator, types.KeyValue, packed_, "customMetadata");
        errdefer {
            for (custom_metadata_) |c| c.deinit(allocator);
            allocator.free(custom_metadata_);
        }
        const features_ = try flatbuffers.unpackVector(allocator, types.Feature, packed_, "features");
        errdefer {
            allocator.free(features_);
        }
        return .{
            .endianness = try packed_.endianness(),
            .fields = fields_,
            .custom_metadata = custom_metadata_,
            .features = features_,
        };
    }

    pub fn deinit(self: Self, allocator: std.mem.Allocator) void {
        for (self.fields) |f| f.deinit(allocator);
        allocator.free(self.fields);
        for (self.custom_metadata) |c| c.deinit(allocator);
        allocator.free(self.custom_metadata);
        allocator.free(self.features);
    }

    pub fn pack(self: Self, builder: *flatbuffers.Builder) flatbuffers.Error!u32 {
        const field_offsets = .{
            .fields = try builder.prependVectorOffsets(types.Field, self.fields),
            .custom_metadata = try builder.prependVectorOffsets(types.KeyValue, self.custom_metadata),
            .features = try builder.prependVector(types.Feature, self.features),
        };

        try builder.startTable();
        try builder.appendTableFieldWithDefault(types.Endianness, self.endianness, .little);
        try builder.appendTableFieldOffset(field_offsets.fields);
        try builder.appendTableFieldOffset(field_offsets.custom_metadata);
        try builder.appendTableFieldOffset(field_offsets.features);
        return builder.endTable();
    }

    pub fn nFields(self: Self) usize {
        var res: usize = 0;
        for (self.fields) |field| res += 1 + field.nFields();
        return res;
    }

    pub fn nBuffers(self: Self) IpcError!usize {
        var res: usize = 0;
        for (self.fields) |field| res += try field.nBuffers();
        return res;
    }

    pub fn initFromArray(allocator: std.mem.Allocator, array: *Array) !Self {
        var fields = try allocator.alloc(types.Field, array.children.len);
        errdefer allocator.free(fields);
        var dict_id: i64 = 0;
        for (fields, array.children) |*f, c|
            f.* = try types.Field.initFromArray(allocator, &dict_id, c);

        return .{
            .fields = fields,
            .custom_metadata = &.{},
            .features = &.{},
        };
    }
};

/// ----------------------------------------------------------------------
/// A Schema describes the columns in a row batch
pub const PackedSchema = struct {
    table: flatbuffers.Table,

    const Self = @This();

    pub fn init(size_prefixed_bytes: []u8) flatbuffers.Error!Self {
        return .{ .table = try flatbuffers.Table.init(size_prefixed_bytes) };
    }

    /// endianness of the buffer
    /// it is Little Endian by default
    /// if endianness doesn't match the underlying system then the vectors need to be converted
    pub fn endianness(self: Self) flatbuffers.Error!types.Endianness {
        return self.table.readFieldWithDefault(types.Endianness, 0, .little);
    }

    pub fn fieldsLen(self: Self) flatbuffers.Error!u32 {
        return self.table.readFieldVectorLen(1);
    }
    pub fn fields(self: Self, index: usize) flatbuffers.Error!types.PackedField {
        return self.table.readFieldVectorItem(types.PackedField, 1, index);
    }

    pub fn customMetadataLen(self: Self) flatbuffers.Error!u32 {
        return self.table.readFieldVectorLen(2);
    }
    pub fn customMetadata(self: Self, index: usize) flatbuffers.Error!types.PackedKeyValue {
        return self.table.readFieldVectorItem(types.PackedKeyValue, 2, index);
    }

    /// Features used in the stream/file.
    pub fn features(self: Self) flatbuffers.Error![]align(1) types.Feature {
        return self.table.readField([]align(1) types.Feature, 3);
    }
};

fn testEquals(field1: types.Field, field2: types.Field) !void {
    errdefer {
        std.debug.print("expected: \n", .{});
        field1.print();

        std.debug.print("actual: \n", .{});
        field2.print();
    }
    try std.testing.expectEqualStrings(field1.name, field1.name);
    try std.testing.expectEqual(field1.nullable, field2.nullable);
    try std.testing.expectEqualDeep(field1.type, field2.type);
    try std.testing.expectEqual(field1.dictionary, field2.dictionary);
    try std.testing.expectEqual(field1.children.len, field2.children.len);
    for (field1.children, field2.children) |c1, c2| try testEquals(c1, c2);
    try std.testing.expectEqual(field1.custom_metadata, field2.custom_metadata);
}

test "initFromArray" {
    const expected_fields = &[_]types.Field{
        .{
            .name = "a",
            .nullable = true,
            .type = .{ .int = types.Int{ .bit_width = 16, .is_signed = true } },
            .children = &.{},
            .custom_metadata = &.{},
        },
        .{
            .name = "b",
            .nullable = true,
            .type = .{ .fixed_size_list = .{ .list_size = 3 } },
            .dictionary = null,
            .children = @constCast(&[_]types.Field{
                .{
                    .name = "i16 builder",
                    .type = .{ .int = .{ .bit_width = 16, .is_signed = true } },
                    .children = &.{},
                    .custom_metadata = &.{},
                },
            }),
            .custom_metadata = &.{},
        },
        .{
            .name = "c",
            .nullable = true,
            .type = .{ .binary = .{} },
            .children = &.{},
            .custom_metadata = &.{},
        },
        .{
            .name = "d",
            .nullable = true,
            .type = .{ .list = .{} },
            .children = @constCast(&[_]types.Field{
                .{
                    .name = "i16 builder",
                    .type = .{ .int = .{ .bit_width = 16, .is_signed = true } },
                    .children = &.{},
                    .custom_metadata = &.{},
                },
            }),
            .custom_metadata = &.{},
        },
        .{
            .name = "e",
            .nullable = true,
            .type = .{ .fixed_size_list = .{ .list_size = 3 } },
            .children = @constCast(&[_]types.Field{
                .{
                    .name = "i16 builder",
                    .type = .{ .int = .{ .bit_width = 16, .is_signed = true } },
                    .children = &.{},
                    .custom_metadata = &.{},
                },
            }),
            .custom_metadata = &.{},
        },
        .{
            .name = "f",
            .nullable = true,
            .type = .{ .struct_ = .{} },
            .children = @constCast(&[_]types.Field{
                .{
                    .name = "a",
                    .nullable = true,
                    .type = .{ .int = .{ .bit_width = 32, .is_signed = true } },
                    .children = &.{},
                    .custom_metadata = &.{},
                },
                .{
                    .name = "b",
                    .nullable = true,
                    .type = .{ .int = .{ .bit_width = 64, .is_signed = false } },
                    .children = &.{},
                    .custom_metadata = &.{},
                },
            }),
            .custom_metadata = &.{},
        },
        .{
            .name = "g",
            .nullable = true,
            .type = .{ .@"union" = .{ .mode = .dense, .type_ids = @constCast(&[_]i32{ 0, 1 }) } },
            .children = @constCast(&[_]types.Field{
                .{
                    .name = "f32 builder",
                    .nullable = true,
                    .type = .{ .floating_point = .{ .precision = .single } },
                    .children = &.{},
                    .custom_metadata = &.{},
                },
                .{
                    .name = "f32 builder",
                    .nullable = true,
                    .type = .{ .int = .{ .bit_width = 32, .is_signed = true } },
                    .children = &.{},
                    .custom_metadata = &.{},
                },
            }),
            .custom_metadata = &.{},
        },
        .{
            .name = "h",
            .nullable = true,
            .type = .{ .@"union" = .{ .mode = .sparse, .type_ids = @constCast(&[_]i32{ 0, 1 }) } },
            .children = @constCast(&[_]types.Field{
                .{
                    .name = "f32 builder",
                    .nullable = true,
                    .type = .{ .floating_point = .{ .precision = .single } },
                    .children = &.{},
                    .custom_metadata = &.{},
                },
                .{
                    .name = "f32 builder",
                    .nullable = true,
                    .type = .{ .int = .{ .bit_width = 32, .is_signed = true } },
                    .children = &.{},
                    .custom_metadata = &.{},
                },
            }),
            .custom_metadata = &.{},
        },
        .{
            .name = "i",
            .nullable = true,
            .type = .{ .binary = .{} },
            .dictionary = .{
                .id = 0,
                .index_type = .{ .bit_width = 8, .is_signed = true },
            },
            .children = &.{},
            .custom_metadata = &.{},
        },
        .{
            .name = "j",
            .nullable = true,
            .type = .{ .map = .{ .keys_sorted = false } },
            .children = @constCast(&[_]types.Field{
                .{
                    .name = "entries",
                    .type = .{ .struct_ = .{} },
                    .children = @constCast(&[_]types.Field{
                        .{
                            .name = "key",
                            .type = .{ .binary = .{} },
                            .children = &.{},
                            .custom_metadata = &.{},
                        },
                        .{
                            .name = "value",
                            .nullable = true,
                            .type = .{ .int = .{ .bit_width = 32, .is_signed = true } },
                            .children = &.{},
                            .custom_metadata = &.{},
                        },
                    }),
                    .custom_metadata = &.{},
                },
            }),
            .custom_metadata = &.{},
        },
    };

    const batch = try arrays.all(std.testing.allocator);
    defer batch.deinit();
    const schema: Schema = try Schema.initFromArray(std.testing.allocator, batch);
    defer schema.deinit(std.testing.allocator);

    try std.testing.expectEqual(expected_fields.len, schema.fields.len);
    for (expected_fields, schema.fields) |f1, f2| try testEquals(f1, f2);
}
