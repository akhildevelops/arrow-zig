//!
//! generated by flatc-zig
//! binary:     src/ipc/gen/format/Schema.bfbs
//! schema:     format/Schema.fbs
//! file ident: //Schema.fbs
//! typename    Time
//!

const std = @import("std");
const fb = @import("flatbufferz");
const Builder = fb.Builder;

const TimeUnit = @import("TimeUnit.fb.zig").TimeUnit;

/// Time is either a 32-bit or 64-bit signed integer type representing an
/// elapsed time since midnight, stored in either of four units: seconds,
/// milliseconds, microseconds or nanoseconds.
///
/// The integer `bitWidth` depends on the `unit` and must be one of the following:
/// * SECOND and MILLISECOND: 32 bits
/// * MICROSECOND and NANOSECOND: 64 bits
///
/// The allowed values are between 0 (inclusive) and 86400 (=24*60*60) seconds
/// (exclusive), adjusted for the time unit (for example, up to 86400000
/// exclusive for the MILLISECOND unit).
/// This definition doesn't allow for leap seconds. Time values from
/// measurements with leap seconds will need to be corrected when ingesting
/// into Arrow (for example by replacing the value 86400 with 86399).
pub const TimeT = struct {
    unit: TimeUnit = @intToEnum(TimeUnit, 1),
    bitWidth: i32 = 32,

    pub fn Pack(rcv: TimeT, __builder: *Builder, __pack_opts: fb.common.PackOptions) fb.common.PackError!u32 {
        _ = .{__pack_opts};
        var __tmp_offsets = std.ArrayListUnmanaged(u32){};
        defer if (__pack_opts.allocator) |alloc| __tmp_offsets.deinit(alloc);
        try Time.Start(__builder);
        try Time.AddUnit(__builder, rcv.unit);
        try Time.AddBitWidth(__builder, rcv.bitWidth);
        return Time.End(__builder);
    }

    pub fn UnpackTo(rcv: Time, t: *TimeT, __pack_opts: fb.common.PackOptions) !void {
        _ = .{__pack_opts};
        t.unit = rcv.Unit();

        t.bitWidth = rcv.BitWidth();
    }

    pub fn Unpack(rcv: Time, __pack_opts: fb.common.PackOptions) fb.common.PackError!TimeT {
        var t = TimeT{};
        try TimeT.UnpackTo(rcv, &t, __pack_opts);
        return t;
    }

    pub fn deinit(self: *TimeT, allocator: std.mem.Allocator) void {
        _ = .{ self, allocator };
    }
};

pub const Time = struct {
    _tab: fb.Table,

    pub fn GetRootAs(buf: []u8, offset: u32) Time {
        const n = fb.encode.read(u32, buf[offset..]);
        return Time.init(buf, n + offset);
    }

    pub fn GetSizePrefixedRootAs(buf: []u8, offset: u32) Time {
        const n = fb.encode.read(u32, buf[offset + fb.Builder.size_u32 ..]);
        return Time.init(buf, n + offset + fb.Builder.size_u32);
    }

    pub fn init(bytes: []u8, pos: u32) Time {
        return .{ ._tab = .{ .bytes = bytes, .pos = pos } };
    }

    pub fn Table(x: Time) fb.Table {
        return x._tab;
    }

    pub fn Unit(rcv: Time) TimeUnit {
        const o = rcv._tab.offset(4);
        if (o != 0) {
            return rcv._tab.read(TimeUnit, o + rcv._tab.pos);
        }
        return @intToEnum(TimeUnit, 1);
    }

    pub fn MutateUnit(rcv: Time, n: TimeUnit) bool {
        return rcv._tab.mutateSlot(TimeUnit, 4, n);
    }

    pub fn BitWidth(rcv: Time) i32 {
        const o = rcv._tab.offset(6);
        if (o != 0) {
            return rcv._tab.read(i32, o + rcv._tab.pos);
        }
        return 32;
    }

    pub fn MutateBitWidth(rcv: Time, n: i32) bool {
        return rcv._tab.mutateSlot(i32, 6, n);
    }

    pub fn Start(__builder: *Builder) !void {
        try __builder.startObject(2);
    }
    pub fn AddUnit(__builder: *Builder, unit: TimeUnit) !void {
        try __builder.prependSlot(TimeUnit, 0, unit, @intToEnum(TimeUnit, 1));
    }

    pub fn AddBitWidth(__builder: *Builder, bitWidth: i32) !void {
        try __builder.prependSlot(i32, 1, bitWidth, 32);
    }

    pub fn End(__builder: *Builder) !u32 {
        return __builder.endObject();
    }

    pub fn Unpack(rcv: Time, __pack_opts: fb.common.PackOptions) !TimeT {
        return TimeT.Unpack(rcv, __pack_opts);
    }
    pub fn FinishBuffer(__builder: *Builder, root: u32) !void {
        return __builder.Finish(root);
    }

    pub fn FinishSizePrefixedBuffer(__builder: *Builder, root: u32) !void {
        return __builder.FinishSizePrefixed(root);
    }
};
