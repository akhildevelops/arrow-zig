//!
//! generated by flatc-zig
//! binary:     gen/format/Schema.bfbs
//! schema:     format/Schema.fbs
//! file ident: //Schema.fbs
//! typename    Type
//!

const std = @import("std");
const fb = @import("flatbufferz");
const Builder = fb.Builder;

const Int = @import("Int.fb.zig").Int;
const IntT = @import("Int.fb.zig").IntT;
const Utf8 = @import("Utf8.fb.zig").Utf8;
const Utf8T = @import("Utf8.fb.zig").Utf8T;
const FixedSizeBinary = @import("FixedSizeBinary.fb.zig").FixedSizeBinary;
const FixedSizeBinaryT = @import("FixedSizeBinary.fb.zig").FixedSizeBinaryT;
const Decimal = @import("Decimal.fb.zig").Decimal;
const DecimalT = @import("Decimal.fb.zig").DecimalT;
const List = @import("List.fb.zig").List;
const ListT = @import("List.fb.zig").ListT;
const FixedSizeList = @import("FixedSizeList.fb.zig").FixedSizeList;
const FixedSizeListT = @import("FixedSizeList.fb.zig").FixedSizeListT;
const Duration = @import("Duration.fb.zig").Duration;
const DurationT = @import("Duration.fb.zig").DurationT;
const Time = @import("Time.fb.zig").Time;
const TimeT = @import("Time.fb.zig").TimeT;
const Struct_ = @import("Struct_.fb.zig").Struct_;
const Struct_T = @import("Struct_.fb.zig").Struct_T;
const Null = @import("Null.fb.zig").Null;
const NullT = @import("Null.fb.zig").NullT;
const Map = @import("Map.fb.zig").Map;
const MapT = @import("Map.fb.zig").MapT;
const Binary = @import("Binary.fb.zig").Binary;
const BinaryT = @import("Binary.fb.zig").BinaryT;
const FloatingPoint = @import("FloatingPoint.fb.zig").FloatingPoint;
const FloatingPointT = @import("FloatingPoint.fb.zig").FloatingPointT;
const Bool = @import("Bool.fb.zig").Bool;
const BoolT = @import("Bool.fb.zig").BoolT;
const Date = @import("Date.fb.zig").Date;
const DateT = @import("Date.fb.zig").DateT;
const LargeBinary = @import("LargeBinary.fb.zig").LargeBinary;
const LargeBinaryT = @import("LargeBinary.fb.zig").LargeBinaryT;
const LargeUtf8 = @import("LargeUtf8.fb.zig").LargeUtf8;
const LargeUtf8T = @import("LargeUtf8.fb.zig").LargeUtf8T;
const Interval = @import("Interval.fb.zig").Interval;
const IntervalT = @import("Interval.fb.zig").IntervalT;
const Union = @import("Union.fb.zig").Union;
const UnionT = @import("Union.fb.zig").UnionT;
const LargeList = @import("LargeList.fb.zig").LargeList;
const LargeListT = @import("LargeList.fb.zig").LargeListT;
const RunEndEncoded = @import("RunEndEncoded.fb.zig").RunEndEncoded;
const RunEndEncodedT = @import("RunEndEncoded.fb.zig").RunEndEncodedT;
const Timestamp = @import("Timestamp.fb.zig").Timestamp;
const TimestampT = @import("Timestamp.fb.zig").TimestampT;

/// ----------------------------------------------------------------------
/// Top-level Type value, enabling extensible type-specific metadata. We can
/// add new logical types to Type without breaking backwards compatibility
pub const Type = union(enum) {
    NONE,
    Null: Null,
    Int: Int,
    FloatingPoint: FloatingPoint,
    Binary: Binary,
    Utf8: Utf8,
    Bool: Bool,
    Decimal: Decimal,
    Date: Date,
    Time: Time,
    Timestamp: Timestamp,
    Interval: Interval,
    List: List,
    Struct_: Struct_,
    Union: Union,
    FixedSizeBinary: FixedSizeBinary,
    FixedSizeList: FixedSizeList,
    Map: Map,
    Duration: Duration,
    LargeBinary: LargeBinary,
    LargeUtf8: LargeUtf8,
    LargeList: LargeList,
    RunEndEncoded: RunEndEncoded,

    pub const Tag = std.meta.Tag(@This());
    pub fn tagName(v: @This()) []const u8 {
        return @tagName(v);
    }
};

pub const TypeT = union(Type.Tag) {
    NONE: void,
    Null: ?*NullT,
    Int: ?*IntT,
    FloatingPoint: ?*FloatingPointT,
    Binary: ?*BinaryT,
    Utf8: ?*Utf8T,
    Bool: ?*BoolT,
    Decimal: ?*DecimalT,
    Date: ?*DateT,
    Time: ?*TimeT,
    Timestamp: ?*TimestampT,
    Interval: ?*IntervalT,
    List: ?*ListT,
    Struct_: ?*Struct_T,
    Union: ?*UnionT,
    FixedSizeBinary: ?*FixedSizeBinaryT,
    FixedSizeList: ?*FixedSizeListT,
    Map: ?*MapT,
    Duration: ?*DurationT,
    LargeBinary: ?*LargeBinaryT,
    LargeUtf8: ?*LargeUtf8T,
    LargeList: ?*LargeListT,
    RunEndEncoded: ?*RunEndEncodedT,

    pub fn deinit(self: *TypeT, allocator: std.mem.Allocator) void {
        switch (self.*) {
            .NONE => {},
            .Null => |mptr| if (mptr) |x| {
                x.deinit(allocator);
                allocator.destroy(x);
                self.Null = null;
            },
            .Int => |mptr| if (mptr) |x| {
                x.deinit(allocator);
                allocator.destroy(x);
                self.Int = null;
            },
            .FloatingPoint => |mptr| if (mptr) |x| {
                x.deinit(allocator);
                allocator.destroy(x);
                self.FloatingPoint = null;
            },
            .Binary => |mptr| if (mptr) |x| {
                x.deinit(allocator);
                allocator.destroy(x);
                self.Binary = null;
            },
            .Utf8 => |mptr| if (mptr) |x| {
                x.deinit(allocator);
                allocator.destroy(x);
                self.Utf8 = null;
            },
            .Bool => |mptr| if (mptr) |x| {
                x.deinit(allocator);
                allocator.destroy(x);
                self.Bool = null;
            },
            .Decimal => |mptr| if (mptr) |x| {
                x.deinit(allocator);
                allocator.destroy(x);
                self.Decimal = null;
            },
            .Date => |mptr| if (mptr) |x| {
                x.deinit(allocator);
                allocator.destroy(x);
                self.Date = null;
            },
            .Time => |mptr| if (mptr) |x| {
                x.deinit(allocator);
                allocator.destroy(x);
                self.Time = null;
            },
            .Timestamp => |mptr| if (mptr) |x| {
                x.deinit(allocator);
                allocator.destroy(x);
                self.Timestamp = null;
            },
            .Interval => |mptr| if (mptr) |x| {
                x.deinit(allocator);
                allocator.destroy(x);
                self.Interval = null;
            },
            .List => |mptr| if (mptr) |x| {
                x.deinit(allocator);
                allocator.destroy(x);
                self.List = null;
            },
            .Struct_ => |mptr| if (mptr) |x| {
                x.deinit(allocator);
                allocator.destroy(x);
                self.Struct_ = null;
            },
            .Union => |mptr| if (mptr) |x| {
                x.deinit(allocator);
                allocator.destroy(x);
                self.Union = null;
            },
            .FixedSizeBinary => |mptr| if (mptr) |x| {
                x.deinit(allocator);
                allocator.destroy(x);
                self.FixedSizeBinary = null;
            },
            .FixedSizeList => |mptr| if (mptr) |x| {
                x.deinit(allocator);
                allocator.destroy(x);
                self.FixedSizeList = null;
            },
            .Map => |mptr| if (mptr) |x| {
                x.deinit(allocator);
                allocator.destroy(x);
                self.Map = null;
            },
            .Duration => |mptr| if (mptr) |x| {
                x.deinit(allocator);
                allocator.destroy(x);
                self.Duration = null;
            },
            .LargeBinary => |mptr| if (mptr) |x| {
                x.deinit(allocator);
                allocator.destroy(x);
                self.LargeBinary = null;
            },
            .LargeUtf8 => |mptr| if (mptr) |x| {
                x.deinit(allocator);
                allocator.destroy(x);
                self.LargeUtf8 = null;
            },
            .LargeList => |mptr| if (mptr) |x| {
                x.deinit(allocator);
                allocator.destroy(x);
                self.LargeList = null;
            },
            .RunEndEncoded => |mptr| if (mptr) |x| {
                x.deinit(allocator);
                allocator.destroy(x);
                self.RunEndEncoded = null;
            },
        }
    }

    pub fn Pack(rcv: TypeT, __builder: *Builder, __pack_opts: fb.common.PackOptions) !u32 {
        // std.debug.print("pack() TypeT rcv=.{s}\n", .{@tagName(rcv)});
        switch (rcv) {
            .NONE => {},
            .Null => |x| return x.?.Pack(__builder, __pack_opts),
            .Int => |x| return x.?.Pack(__builder, __pack_opts),
            .FloatingPoint => |x| return x.?.Pack(__builder, __pack_opts),
            .Binary => |x| return x.?.Pack(__builder, __pack_opts),
            .Utf8 => |x| return x.?.Pack(__builder, __pack_opts),
            .Bool => |x| return x.?.Pack(__builder, __pack_opts),
            .Decimal => |x| return x.?.Pack(__builder, __pack_opts),
            .Date => |x| return x.?.Pack(__builder, __pack_opts),
            .Time => |x| return x.?.Pack(__builder, __pack_opts),
            .Timestamp => |x| return x.?.Pack(__builder, __pack_opts),
            .Interval => |x| return x.?.Pack(__builder, __pack_opts),
            .List => |x| return x.?.Pack(__builder, __pack_opts),
            .Struct_ => |x| return x.?.Pack(__builder, __pack_opts),
            .Union => |x| return x.?.Pack(__builder, __pack_opts),
            .FixedSizeBinary => |x| return x.?.Pack(__builder, __pack_opts),
            .FixedSizeList => |x| return x.?.Pack(__builder, __pack_opts),
            .Map => |x| return x.?.Pack(__builder, __pack_opts),
            .Duration => |x| return x.?.Pack(__builder, __pack_opts),
            .LargeBinary => |x| return x.?.Pack(__builder, __pack_opts),
            .LargeUtf8 => |x| return x.?.Pack(__builder, __pack_opts),
            .LargeList => |x| return x.?.Pack(__builder, __pack_opts),
            .RunEndEncoded => |x| return x.?.Pack(__builder, __pack_opts),
        }
        return 0;
    }

    pub fn Unpack(rcv: Type.Tag, table: fb.Table, __pack_opts: fb.common.PackOptions) !TypeT {
        // std.debug.print("unpack() Type rcv=.{s}\n", .{@tagName(rcv)});
        _ = .{__pack_opts};
        switch (rcv) {
            .NONE => return .NONE,
            .Null => {
                var x = Null.init(table.bytes, table.pos);
                var ptr = try __pack_opts.allocator.?.create(NullT);
                ptr.* = try NullT.Unpack(x, __pack_opts);
                return .{ .Null = ptr };
            },
            .Int => {
                var x = Int.init(table.bytes, table.pos);
                var ptr = try __pack_opts.allocator.?.create(IntT);
                ptr.* = try IntT.Unpack(x, __pack_opts);
                return .{ .Int = ptr };
            },
            .FloatingPoint => {
                var x = FloatingPoint.init(table.bytes, table.pos);
                var ptr = try __pack_opts.allocator.?.create(FloatingPointT);
                ptr.* = try FloatingPointT.Unpack(x, __pack_opts);
                return .{ .FloatingPoint = ptr };
            },
            .Binary => {
                var x = Binary.init(table.bytes, table.pos);
                var ptr = try __pack_opts.allocator.?.create(BinaryT);
                ptr.* = try BinaryT.Unpack(x, __pack_opts);
                return .{ .Binary = ptr };
            },
            .Utf8 => {
                var x = Utf8.init(table.bytes, table.pos);
                var ptr = try __pack_opts.allocator.?.create(Utf8T);
                ptr.* = try Utf8T.Unpack(x, __pack_opts);
                return .{ .Utf8 = ptr };
            },
            .Bool => {
                var x = Bool.init(table.bytes, table.pos);
                var ptr = try __pack_opts.allocator.?.create(BoolT);
                ptr.* = try BoolT.Unpack(x, __pack_opts);
                return .{ .Bool = ptr };
            },
            .Decimal => {
                var x = Decimal.init(table.bytes, table.pos);
                var ptr = try __pack_opts.allocator.?.create(DecimalT);
                ptr.* = try DecimalT.Unpack(x, __pack_opts);
                return .{ .Decimal = ptr };
            },
            .Date => {
                var x = Date.init(table.bytes, table.pos);
                var ptr = try __pack_opts.allocator.?.create(DateT);
                ptr.* = try DateT.Unpack(x, __pack_opts);
                return .{ .Date = ptr };
            },
            .Time => {
                var x = Time.init(table.bytes, table.pos);
                var ptr = try __pack_opts.allocator.?.create(TimeT);
                ptr.* = try TimeT.Unpack(x, __pack_opts);
                return .{ .Time = ptr };
            },
            .Timestamp => {
                var x = Timestamp.init(table.bytes, table.pos);
                var ptr = try __pack_opts.allocator.?.create(TimestampT);
                ptr.* = try TimestampT.Unpack(x, __pack_opts);
                return .{ .Timestamp = ptr };
            },
            .Interval => {
                var x = Interval.init(table.bytes, table.pos);
                var ptr = try __pack_opts.allocator.?.create(IntervalT);
                ptr.* = try IntervalT.Unpack(x, __pack_opts);
                return .{ .Interval = ptr };
            },
            .List => {
                var x = List.init(table.bytes, table.pos);
                var ptr = try __pack_opts.allocator.?.create(ListT);
                ptr.* = try ListT.Unpack(x, __pack_opts);
                return .{ .List = ptr };
            },
            .Struct_ => {
                var x = Struct_.init(table.bytes, table.pos);
                var ptr = try __pack_opts.allocator.?.create(Struct_T);
                ptr.* = try Struct_T.Unpack(x, __pack_opts);
                return .{ .Struct_ = ptr };
            },
            .Union => {
                var x = Union.init(table.bytes, table.pos);
                var ptr = try __pack_opts.allocator.?.create(UnionT);
                ptr.* = try UnionT.Unpack(x, __pack_opts);
                return .{ .Union = ptr };
            },
            .FixedSizeBinary => {
                var x = FixedSizeBinary.init(table.bytes, table.pos);
                var ptr = try __pack_opts.allocator.?.create(FixedSizeBinaryT);
                ptr.* = try FixedSizeBinaryT.Unpack(x, __pack_opts);
                return .{ .FixedSizeBinary = ptr };
            },
            .FixedSizeList => {
                var x = FixedSizeList.init(table.bytes, table.pos);
                var ptr = try __pack_opts.allocator.?.create(FixedSizeListT);
                ptr.* = try FixedSizeListT.Unpack(x, __pack_opts);
                return .{ .FixedSizeList = ptr };
            },
            .Map => {
                var x = Map.init(table.bytes, table.pos);
                var ptr = try __pack_opts.allocator.?.create(MapT);
                ptr.* = try MapT.Unpack(x, __pack_opts);
                return .{ .Map = ptr };
            },
            .Duration => {
                var x = Duration.init(table.bytes, table.pos);
                var ptr = try __pack_opts.allocator.?.create(DurationT);
                ptr.* = try DurationT.Unpack(x, __pack_opts);
                return .{ .Duration = ptr };
            },
            .LargeBinary => {
                var x = LargeBinary.init(table.bytes, table.pos);
                var ptr = try __pack_opts.allocator.?.create(LargeBinaryT);
                ptr.* = try LargeBinaryT.Unpack(x, __pack_opts);
                return .{ .LargeBinary = ptr };
            },
            .LargeUtf8 => {
                var x = LargeUtf8.init(table.bytes, table.pos);
                var ptr = try __pack_opts.allocator.?.create(LargeUtf8T);
                ptr.* = try LargeUtf8T.Unpack(x, __pack_opts);
                return .{ .LargeUtf8 = ptr };
            },
            .LargeList => {
                var x = LargeList.init(table.bytes, table.pos);
                var ptr = try __pack_opts.allocator.?.create(LargeListT);
                ptr.* = try LargeListT.Unpack(x, __pack_opts);
                return .{ .LargeList = ptr };
            },
            .RunEndEncoded => {
                var x = RunEndEncoded.init(table.bytes, table.pos);
                var ptr = try __pack_opts.allocator.?.create(RunEndEncodedT);
                ptr.* = try RunEndEncodedT.Unpack(x, __pack_opts);
                return .{ .RunEndEncoded = ptr };
            },
        }
        unreachable;
    }
};
